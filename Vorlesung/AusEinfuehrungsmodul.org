* Material aus Einführung
** Einleitung
*** Stoffsammlung
+ warum Programmiersprachen?
+ formale Sprachen vs. natürliche Sprachen
+ Informationen und Daten
+ vgl. auch [[http://www.htdp.org/2003-09-26/Book/curriculum-Z-H-4.html#node_chap_1][Einleitung in HtdP]]

** Einstieg: elementare Ausdrücke/Funktionen
*** Auswertung arithmetischer Ausdrücke
+ wir beginnen mit Zahlen
+ FuProLang[fn:1] kennt 
+ ganze Zahlen (integers) : 6, -12
+ rationale Zahlen (rationals, fractions): 2/3, 8/7
+ Dezimalzahlen, auch Gleitkommazahlen (decimals, floating point
numbers): 3.14159, 6.0, 2.1E7 (entspricht $2.1\cdot 10^7$)[fn:2]
+ Zahlen werden zu sich selbst ausgewertet (self evaluating
expression).
#+REVEAL: split
+ /Regieanweisung: Beispiele für die Auswertung von Zahlen in der
REPL zeigen!/
+ Grundform des arithmetischen Ausdrucks (in /FuProlang/):
: (operator operand-1 operand-2 ... operand-n)
+ Beispiele: 
#+begin_src clojure
(+ 1 2 3)
(* 3 4 5)
(/ 9  3)
(/ 3 9)
(/ 1.0 3.0)
(* (+ 2 2) (/ (* (+ 3 5) (/ 30 10)) 2))
#+end_src
+ Aufgaben: 
1. Wie wird der letzte Ausdruck ausgewertet?
2. Experimentieren Sie mit verschiedenen Operatoren und
Zahlenarten (s. o.)
3. Werten Sie die folgenden Ausdrücke aus und vergleichen Sie die
Resultate:
: (- 1.0 0.9) 
und
: (- 1000.0 999.9) 
*** Anwendung und Definition einfacher Funktionen in der Repl
**** Funktionale Abstraktion
+ Problem: Berechnung der Ökosteuer bei:
+ gegebenem Preis für die Tankfüllung Benzin: 5400 Eurocent,
+ gegebenem Preis pro Liter: 150 Eurocent und
+ gegegenem Ökosteueranteil: 7 Cent/l)
+ Lösung: $\frac{4500}{150}\cdot 7$ oder
: (* (/ 4500 150) 7)
+ Verallgemeinerung der Berechnungsvorschrift, wenn der Preis für die
Tankfüllung und der Literpreis als variabel sind, der
Ökosteueranteil hingegen fest ist:
$\frac{preis-fuer-tankfuellung}{preis-pro-liter}\cdot 7$ oder
: (* (/ preis-fuer-tankfuellung preis-pro-liter) 7)
Dieser Ausdruck ist nicht auswertbar. Warum nicht?
+ Abstraktionsschritt: Definition der Berechnungsvorschrift als Funktion:
\begin{equation}
f(preis\text{-}fuer\text{-}tankfuellung, preis\text{-}pro\text{-}liter) = \frac{preis\text{-}fuer\text{-}tankfuellung}{preis\text{-}pro\text{-}liter}\cdot 7
\end{equation}
Die Funktion könnte dann so benutzt werden:
Der Ausdruck $f(4500, 150)$ liefert als Resultat $210$.
+ In /Fuprolang/ besteht die Abstraktion aus zwei Schritten.
1. Definition der Berechnungsvorschrift als Funktion:
: (fn [preis-fuer-tankfuellung preis-pro-liter]
:     (* (/ preis-fuer-tankfuellung preis-pro-liter) 7))
Dieser Ausdruck ist auswertbar, das Resultat ist eine Funktion. Eine
Funktion kann in /FuProlang/ wie ein Operator verwendet werden:
: (function operand-1 operand-2 ... operand-n)
Ersetzt man „function” durch obige Funktion, kann diese wie folgt
angewendet werden:
: ( (fn [preis-fuer-tankfuellung preis-pro-liter]
:       (* (/ preis-fuer-tankfuellung preis-pro-liter) 7))
:   4500 150)
Das Resultat ist wieder 210.
2. Mit dieser Abstraktion ist insofern noch nicht so viel gewonnen,
als die Funktionsdefinition bei jeder Anwendung der Funktion
erneut mit angegeben werden müsste. Deswegen erlaubt /Fuprolang/
die Bindung einer Berechnungsvorschrift (Funktion) an einen
Namen:
: (def oeko-steuer
:      (fn [preis-fuer-tankfuellung preis-pro-liter]
:          (* (/ preis-fuer-tankfuellung preis-pro-liter) 7)))
Danach kann die Funktion durch Angabe des Namens angewendet
werden. So liefert der Ausdruck
: (oeko-steuer 4500 150)
wieder den Wert 210.
**** Ausdrücke in /FuProLang/ (1)
Nach dem zuvor Erläuterten kann der Aufbau von Ausdrücken in
/FuProlang/ wie folgt präzisiert werden. Die Grundform bleibt dabei
unverändert: 
: (operator operand-1 operand-2 ... operand-n)
/Operatoren/ sind Namen von
+  Standardfunktionen wie z. B:  +, /, *, - für die vier Grundrechenarten
+  eigenen Funktionen: =oeko-steuer=
+  Pseudofunktionen: =def=, =fn=
+  namenlose Funktionen (fn-Ausdrücke[fn:3])
/Operanden/ sind
+  Konstanten: 3.14, 4500, 2/3
+  Variable: =preis-pro-liter=
+  Ausdrücke: =(f ...)=
*Anmerkung:* /FuProlang/ kennt auch noch andere Konstanten als Zahlen,
außerdem eine Vielzahl von Standardfunktionen. Dazu später mehr je
nach Bedarf.
**** Aufgaben
1. Funktionsdefinitionen auf der Grundlage mathematischer Formeln:

a) $n^2 + 1$

b) $\frac{1}{2}n^2 + 3$

c) $2 - \frac{1}{n}$

2. In der Praxis findet der Programmierer selten mathematische Formeln
   vor. Aufgabenstellungen sind eher als Prosatext gegeben. Die
   Berechnungsformeln muss er selbst entwickeln durch 

   + eigenes Nachdenken,
   + Nachschlagen in geeigneten Quellen oder
   + Nachfragen beim Auftraggeber.

Finden Sie für die folgenden Aufgabenstellungen die passenden
Formeln und schreiben Sie diese als Funktionsdefinitionen in
/FuProlang/ auf:

a) Berechnung des Rauminhalts eines Quaders aus dessen Länge, Breite und Höhe.

b) Schreiben Sie eine Funktion, die aus der Entfernung und der
Geschwindigkeit zweier Züge die Zeit ermittelt, nach der die Züge
sich treffen, wenn Sie sich auf einem gemeinsamen Streckenabschnitt
von ihren jeweiligen Startpunkten aus aufeinander zu bewegen.

c) Berechnung des Endkapitals aus einem gegebenen Anfangskapital, einem
Jahreszinssatz und einer in Monaten gemessenen Laufzeit.  Die
Zinsgutschrift erfolgt einmalig am Ende der Laufzeit.  Während der
Laufzeit  gibt es weder Einzahlungen    noch Abhebungen.

d) Berechnung der Miete, die eine andere Spielerin in Monopoly bezahlen muss, falls sie auf
einen Bahnhof trifft, der einer anderen Spielerin gehört. Die Miete
ist davon abhängig wie viele Bahnhöfe der anderen Spielerin
gehören:
| Anzahl der Bahnhöfe | Miete |
|---------------------+-------|
|                   1 |   500 |
|                   2 |  1000 |
|                   3 |  2000 |
|                   4 |  4000 |
Hinweis: Ein Aufruf =(Math/pow x y)= liefert $x^y$ als Ergebnis.

3. Arbeiten mit der /FuProlang/-Konsole, auch „read eval print loop”
(REPL) genannt

Schreiben Sie die Funktionsdefinitionen aus der vorigen Aufgabe in
eine oder mehrere Textdateien (reinen Text, ohne Formatierungen)
und laden sie anschließend in die Repl[fn:4]. Geben Sie dort verschiedene
Ausdrücke ein, um Ihre Funktionen auszuführen

**** Aufschreibregeln für Funktionen

Was tut diese Funktion?
#+begin_src clojure
(def e
  (fn [a z l]
    (+ a 
       (* a 
          (/ z 100 12) l))))
#+end_src

*Regel 1:* Verwende aussagekräftige Namen für Funktionen und Variablen
(„sprechende Bezeichner”)!
#+begin_src clojure
(def endkapital 
  (fn [anfangskapital jahreszinssatz laufzeit-in-monaten]
    (+ anfangskapital 
       (* anfangskapital
          (/ jahreszinssatz 100 12) laufzeit-in-monaten))))
#+end_src

*Regel 2:* Beschreibe den *Zweck der Funktion* durch einen Satz, der das
Resultat der Funktion *in Abhängigkeit von ihren Argumenten* beschreibt.
#+begin_src clojure
;; Aus dem anfangskapital, einem jahreszinssatz  und einer laufzeit-in-monaten wird
;; das Endkapital ermittelt, wobei die Zinsgutschrift einmalig am Ende der Laufzeit 
;; erfolgt.
(def endkapital 
  (fn [anfangskapital jahreszinssatz laufzeit-in-monaten]
    (+ anfangskapital 
       (* anfangskapital
          (/ jahreszinssatz 100 12) laufzeit-in-monaten))))
#+end_src

*Regel 3:* Schreibe Beispielanwendungen der Funktion auf, die das
Resultat der Funktion mit dem Erwartungswert vergleicht. Die
Auswertung der Ausdrücke muss dabei immer den Wahrheitswert =true= liefern[fn:5]:
#+begin_src clojure
;; Aus dem anfangskapital, einem jahreszinssatz  und einer laufzeit-in-monaten wird
;; das Endkapital ermittelt, wobei die Zinsgutschrift einmalig am Ende der Laufzeit 
;; erfolgt.
(def endkapital 
  (fn [anfangskapital jahreszinssatz laufzeit-in-monaten]
    (+ anfangskapital 
       (* anfangskapital
          (/ jahreszinssatz 100 12) laufzeit-in-monaten))))
;; Beispielanwendungen:
(= (endkapital 1000 0 24) 1000)   ;; => true
(= (endkapital 1000 12 12) 1120)  ;; => true
(= (endkapital 1000 12 24) 1240)  ;; => true
#+end_src

*Funktionen, die nicht gemäß diesen Regeln aufgeschrieben sind, sind
unzulässig!*

**** Ausdrücke in /FuProLang/ (2)
Die in Abschnitt 
[[*Ausdrücke in /FuProLang/ (1)][Ausdrücke in /FuProlang/ (1)]] beschriebenen Operatoren und Operanden
werden wie folgt ergänzt:
+ Operatoren
+ Die Standardfunktion = vergleicht zwei Werte und liefert einen der beiden
Wahrheitswerte =true= oder =false= als Resultat.
+ Zum Vergleich von Zahlen gibt es außerdem die Standardfunktionen ~<,
>, <=, >=~
+ Operanden
+ Neben den Zahlenkonstanten gibt es ab sofort auch die booleschen
Konstanten =true= und =false=. 
**** Aufgaben
1. Schreiben Sie die Funktion zur Berechnung der Bahnhofsmiete in
Monopoly (s. o.) gemäß den oben genannten Regel 1 bis 3 auf.
2. Ein altmodisches Vorstadtkino besitzt eine einfache Formel für die
Berechnung des Profits einer Vorstellung: Jeder Kinobesucher
bezahlt 500 Währungseinheiten für die Eintrittskarte. Jede
Vorstellung kostet das Kino 2000 Währungseinheiten plus 50
Währungseinheiten pro Besucher. Schreiben Sie eine Funktion zur
Berechnung des Profits bei gegebener Besucherzahl.
*** Zusammengesetzte Funktionen
Bei der Definition unserer bisherigen Funktionen waren wir darauf
angewiesen, bereits existierende Funktionen (in Form der
                                                arithmetischen Operatoren) nutzen zu können. Für die Lösung
komplexerer Aufgabenstellungen werden wir nicht mit einer einzigen
eigenen Funktion auskommen sondern für die Lösung von Teilaufgaben
auch eigene Funktionen (auch Hilfsfunktionen genannt) zu nutzen, die
dann zur Gesamtlösung zusammengesetzt werden. 

Die Nutzung von Hilfsfunktionen erleichtert nicht nur den Entwurf
komplexerer Programme sondern erhöht auch ihre Lesbarkeit. 

# [[hier gehört noch ein Bild rein !!!]]

Betrachten wir dazu zwei Varianten einer Funktion, die die Fläche
eines Kreisrings berechnet:
#+begin_src clojure
(def kreisring-flaeche
  (fn [radius-aussen radius-innen]
    (- (* 3.14 (* radius-aussen radius-aussen))
       (* 3.14 (* radius-innen  radius-innen)))))
#+end_src
Unter der Voraussetzung, dass eine Funktion zur Berechnung
der Kreisfläche zur Verfügung steht -- wie z. B. diese:
#+begin_src clojure
(def kreis-flaeche
  (fn [radius]
    (* 3.14 (* radius radius))))
#+end_src
--, kann die Funktion =kreisring-flaeche= auch so geschrieben werden.
#+begin_src clojure
(def kreisring-flaeche
  (fn [radius-aussen radius-innen]
    (- (kreis-flaeche radius-aussen)
       (kreis-flaeche radius-innen))))
#+end_src
In der zweiten Variante der Funktion wird die Hilfsfunktion
=kreis-flaeche= benutzt. Damit wird das Problem der Berechnung der
Fläche des Kreisrings explizit auf die Subtraktion zweier Kreisflächen
zurück geführt, während man dies in der ersten Variante erst aus dem
Programmcode herauslesen müsste.

Betrachten wir nun als weiteres Beispiel eine Erweiterung  der
Problembeschreibung der Profitberechnung für den Eigentümer eines
Vorstadtkinos:

#+BEGIN_QUOTE
Er kann die Preise für die Eintrittskarten frei festlegen. Er hat
einen exakten Zusammenhang 
zwischen dem Kartenpreis und der durchschnittlichen Besucheranzahl
empirisch festgestellt: Bei einem Preis von 500 Währungseinheiten
pro Karte kommen im Schnitt 120 Zuschauer. Reduziert er den Preis
um 10 Währungseinheiten, erhöht sich die Besucherzahl um 15. Aber
mehr Besucher verursachen höhere Kosten. Jede Veranstaltung kostet
18000 Währungseinheiten plus 5 Währungseinheiten für jeden
Zuschauer. Der Eigentümer möchte nun wissen, wie groß der Profit
bei einem bestimmten Kartenpreis ist.
#+END_QUOTE
Versuchen wir zunächst die Abhängigkeiten zu erkennen, die sich aus
der Problembeschreibung ableiten lassen:
+ Der /Profit/ ist die Differenz aus Einnahmen und Kosten.

+ Die /Einnahmen/ sind das Produkt aus Kartenpreis und Besucheranzahl.

+ Die /Kosten/ sind die Summe aus den Fixkosten (18000
                                                 Währungseinheiten) und dem Produkt aus Besucheranzahl und den Kosten
pro Besucher (5 Währungseinheiten).

+ Schließlich gibt es noch den empirischen Zusammenhang zwischen
/Besucheranzahl/ und Kartenpreis.

Die weitere Vorgehensweise ist nun dadurch gekennzeichnet, dass für
jeden der ermittelten Zusammenhänge je eine Funktion geschrieben
wird. Dabei gehen wir in 3 Schritten vor:

1. Für jede Funktion wird zunächst gemäß Regel 2 ihre Zweckbestimmung
und ihr Funktionskopf (Name der Funktion und die Parameterliste)
aufgeschrieben.
2. Jetzt werden gemäß Regel 3 Beispielanwendungen hinzugefügt. 
3. Schließlich wird für jede Funktion die Berechnungsvorschrift, der
Funktionrumpf ermittelt.

**** Schritt 1 für die Funktion =profit= und ihre Hilfsfunktionen

+ Die Funktion =profit=:

#+begin_src clojure
;; berechnet den Profit aus der Differenz zwischen
;; Einnahmen und Kosten bei gegebenem Kartenpreis
(def profit
  (fn [kartenpreis]
    nil))
#+end_src

Das Symbol =nil= steht hier als Platzhalter für den noch zu
bestimmenden Funktionsrumpf.

+ Die Berechnung der Einnahmen:

#+begin_src clojure
;; berechnet die Einnahmen aus dem Produkt von 
;; Besucherzahl und Kartenpreis
(def einnahmen
  (fn [kartenpreis]
    nil))
#+end_src

+ Die Berechnung der Kosten:

#+begin_src clojure
;; berechnet die entstehenden Kosten bei gegebenem
;; Kartenpreis aus Fixkosten und variablen Kosten
(def kosten
  (fn [kartenpreis]
    nil))
#+end_src

+ Die Berechnung der Besucherzahl:

#+begin_src clojure
;; berechnet die Besucherzahl bei gegebenem
;; Kartenpreis nach empirisch ermittelter Formel
(def besucherzahl
  (fn [kartenpreis]
    nil))
#+end_src

**** Schritt 2 für die Funktion =profit= und ihre Hilfsfunktionen

In diesem Schritt versuchen wir Beispielanwendungen zu finden;
beginnen wir mit der Funktion =besucherzahl=.

-  Aus der Problembeschreibung lassen sich direkt die beiden folgende Beispiele ableiten:

-  (besucherzahl 500) = 120

-  (besucherzahl 490) = 135

-  Für weitere Beispiele müssten Annahmen getroffen werden, die die
Problembeschreibung nicht direkt hergeben. So sind die beiden
folgenden Beispiele nur dann korrekt, wenn aus den Beispielen der
Problembeschreibung eine linearer Zusammenhang zwischen dem
Kartenpreis und der Besucherzahl angenommen wird:

-  (besucherzahl 510) = 105

-  (besucherzahl 400) = 270

Ob diese Annahme sinnvoll ist, müsste letztendlich der Auftraggeber
entscheiden. Für die folgenden Betrachtungen legen wir diese
Annahme zugrunde.

+ Beispielanwendungen für die Funkton =besucherzahl=:

#+begin_src clojure
;; berechnet die Besucherzahl bei gegebenem
;; Kartenpreis nach empirisch ermittelter Formel
(def besucherzahl
  (fn [kartenpreis]
    nil))

;; Beispielanwendungen
(= (besucherzahl 500) 120)
(= (besucherzahl 490) 135)
(= (besucherzahl 510) 105)
(= (besucherzahl 400) 270)
#+end_src

+ Beispielanwendungen für die Funkton =kosten=:

#+begin_src clojure
;; berechnet die entstehenden Kosten bei gegebenem
;; Kartenpreis aus Fixkosten und variablen Kosten
(def kosten
  (fn [kartenpreis]
    nil))

;; Beispielanwendungen
(= (kosten 500) 18600)
(= (kosten 400) 19350)
#+end_src

+ Beispielanwendungen für die Funkton =einnahmen=:

#+begin_src clojure
;; berechnet die Einnahmen aus dem Produkt von 
;; Besucherzahl und Kartenpreis
(def einnahmen
  (fn [kartenpreis]
    nil))

;; Beispielanwendungen
(= (einnahmen 500) 60000)
(= (einnahmen 400) 108000)
#+end_src

+ Beispielanwendungen für die Funkton =profit=:

#+begin_src clojure
;; berechnet den Profit aus der Differenz zwischen
;; Einnahmen und Kosten bei gegebenem Kartenpreis
(def profit
  (fn [kartenpreis]
    nil))

;; Beispielanwendungen
(= (profit 500) 41400)
(= (profit 400) 88650)
#+end_src

im Schritt Funktionsrumpf:

-  Ein linearer Zusammenhang ergäbe den die folgende Geradengleichung:
$besucherzahl(kartenpreis) = 120 + \frac{15}{10}\cdot (500 - kartenpreis)$

**** Schritt 3: Ermittlung des Funktionsrumpfs für die Funktion =profit= und ihre Hilfsfunktionen

+ Beginnen wir wieder mit der Funktion =besucherzahl=. Der für die
Ermittlung der Beispielanwendungen zugrunde gelegte lineare
Zusammenhang zwischen Besucherzahl und Kartenpreis wird direkt in die
Berechnungsvorschrift für die Funktion genutzt:

#+begin_src clojure
;; berechnet die Besucherzahl bei gegebenem
;; Kartenpreis nach empirisch ermittelter Formel
(def besucherzahl
  (fn [kartenpreis]
    (+ 120 (* (/ 15 10) (- 500 kartenpreis)))))

;; Beispielanwendungen
(= (besucherzahl 500) 120)
(= (besucherzahl 490) 135)
(= (besucherzahl 510) 105)
(= (besucherzahl 400) 270)
#+end_src

+ Die Berechnungsvorschrift der Funktion =kosten= ergibt sich aus dem
oben formulierten Zusammenhang (Die Kosten sind die Summe aus den
                                    Fixkosten (18000 Währungseinheiten) und dem Produkt aus
                                    Besucheranzahl und den Kosten pro Besucher (5 Währungseinheiten).):

#+begin_src clojure
;; berechnet die entstehenden Kosten bei gegebenem
;; Kartenpreis aus Fixkosten und variablen Kosten
(def kosten
  (fn [kartenpreis]
    (+ 18000 (* 5 (besucherzahl kartenpreis)))))

;; Beispielanwendungen
(= (kosten 500) 18600)
(= (kosten 400) 19350)
#+end_src

Man beachte, dass die Funktion =kosten= die Funktion =besucherzahl=
als Hilfsfunktion benutzt.

+ Die Berechnungsvorschrift für die Funktion =einnahmen= als aus
Produkt aus Besucherzahl und Kartenpreis:

#+begin_src clojure
;; berechnet die Einnahmen aus dem Produkt von 
;; Besucherzahl und Kartenpreis
(def einnahmen
  (fn [kartenpreis]
    (* (besucherzahl kartenpreis) kartenpreis)))

;; Beispielanwendungen
(= (einnahmen 500) 60000)
(= (einnahmen 400) 108000)
#+end_src

Man beachte auch hier die Verwendung von =besucherzahl= als
Hilfsfunktion.

+ Schließlich werden in der Berechnungsvorschrift für =profit= die
Funktionen =einnahmen= und =kosten= benutzt:

#+begin_src clojure
;; berechnet den Profit aus der Differenz zwischen
;; Einnahmen und Kosten bei gegebenem Kartenpreis
(def profit
  (fn [kartenpreis]
    (- (einnahmen kartenpreis)
       (kosten kartenpreis))))

;; Beispielanwendungen
(= (profit 500) 41400)
(= (profit 400) 88650)
#+end_src

**** Zusammenfassung

*Regel 4 (Hilfsfunktionen):*

#+BEGIN_QUOTE
*Definiere für jeden Zusammenhang zwischen Größen, die sich aus der
Problembeschreibung ergeben, eine Funktion.*
#+End_Quote

Man könnte die Funktion =profit= auch ohne die Verwendung von
Hilfsfunktionen aufschreiben:

#+begin_src clojure
(def profit
  (fn [kartenpreis]
    (-
     (*
      (+ 120
         (* (/ 15 10 )
            (- 500 kartenpreis)))
      kartenpreis)
     (+ 18000
        (* 5
           (+ 120
              (* (/ 15 10 )
                 (- 500 kartenpreis))))))))
#+end_src

Diese Funktion berechnet das Gleiche wie die Variante mit
Hilfsfunktionen, ist aber völlig unlesbar. Sollte in dieser Funktion
der Zusammenhang zwischen Kartenpreis und Besucherzahl geändert werden
müssen, wäre dies eine nur schwer lösbare Aufgabe.


**** Konstantendefinitionen

Die Lesbarkeit der Funktion =profit= (in beiden Varianten) und ihrer
Hilfsfunktionen ist auch dadurch eingeschränkt, dass in den
Berechnungsvorschriften eine Reihe von Zahlen auftreten, deren
Bedeutung nicht unmittelbar einleuchtend sein muss.
Programms durch

*Regel 5 Konstantendefinitionen:*

#+BEGIN_QUOTE 
*Ersetze jede Konstante, deren Bedeutung sich nicht aus dem Kontext
ergibt, durch einen sprechenden Variablennamen.*
#+END_QUOTE

Zum Beispiel für die
Funktion =profit= und ihre Hilfsfunktionen:

#+begin_src clojure
(def fixkosten 18000)
(def kosten-pro-besucher 5)
(def basis-besucherzahl 120)
(def besucher-preis-faktor (/ 15 10))
(def preis-fuer-basis-besucherzahl 500)        
#+end_src

(Das vollständige Programm =profit= (kino.clj) steht in ... zur
     Verfügung.)

*Gegenbeispiel:* In der Formel zur Berechnung der Dreiecksfläche

: (/ (* grundseite hoehe) 2)

*nicht* die Konstante 2 durch eine eine benannte Konstante =zwei= ersetzen.

**** Aufgaben

1. Modifizieren Sie das Programm =kino.clj= so, dass die 
Fixkosten  eine Veranstaltung wegfallen und dafür 15
Währungseinheiten pro Besucher an Kosten anfallen.
2. Nehmen Sie die gleiche Modifikation auch an der Funktion =profit=
vor, die ohne Hilfsfunktionen auskommt und vergleichen Sie die
Ergebnisse.
Die folgenden Aufgaben sind unter Benutzung von Hilfsfunktionen zu
lösen. Befolgen Sie unbedingt alle oben angegebenen Regeln:
3. [@3]Schreiben Sie ein Programm, das das Volumen eines Zylinders zu
berechnen erlaubt. Eingangsgrößen sind der Radius und die Höhe
des Zylinders.
4. Schreiben Sie ein Programm, das die Oberfläche eines Zylinders zu
berechnen erlaubt. Eingangsgrößen sind der Radius und die Höhe
des Zylinders.
5. Schreiben Sie ein Programm, das die Oberfläche eines Rohrs zu
berechnen erlaubt. Eingangsgrößen sind der Innenradius, die
Wandstärke und die Länge des Rohrs.

**** Ergänzende Hinweise:
/noch auszuführen/
-  top-down vs. bottom-up

-  Hilfsfunktionen entsprechen dem Prinzip der funktionalen Abstraktion

-  oder der hierarchischen Dekomposition

-  program development by stepwise refinement

*** Auswertungsregeln -- elementare Algebra (äquivalente Umformungen)
# +Stichworte:
# + Referenztransparenz
# + Gelichungsumformungen
# + vgl. Func. Prog. in Scala
# + Beispiel: binomische Formel
# + Syntax vs. Semantik

**** Syntax und Semantik einer mathematischen Formelsprache
Die Auswertung von Ausdrücken in /FuProlang/ basiert auf der Anwendung
einfacher äquivalenter Umformungen, wie sie aus der Schulmathematik
bekannt sein sollten.

Betrachten wir folgende mathematische Funktion:
\begin{equation}
bf(a,b) = a\cdot a + 2ab + b\cdot b
\end{equation}
Halten wir zunächst fest, dass diese Funktionsdefinition in einer
definierten mathematischen Formelsprache aufgeschrieben ist. Die
Sprache definiert einige grammatikalische Regeln, die beim
Aufschreiben von Formeln einzuhalten sind. Diese Regeln bezeichnet man
auch als die /Syntax/ der Sprache. Die Syntax der mathematischen
Formelsprache legt z. B. fest, dass

+ Konstanten (Zahlen bzw. Ziffernfolgen),
+ Variablen ($a$, $b$) und
+ bestimmte Operationszeichen (z. B. $+$, $-$ oder der Bruchstrich)

verwendet werden dürfen. Zu den Syntaxregeln gehört aber z. B auch,
dass 

+ links und rechts von Operationszeichen $+$ jeweils ein Operand
stehen muss und dass
+ die Zeichenfolge $2ab$ als Abkürzung für $2\cdot a\cdot b$
geschrieben werden darf, das Operationszeichen $\cdot$ also in bestimmten
Situationen weggelassen werden darf.

Die Syntaxregeln der Sprache sagen nun aber zunächst nichts darüber
aus, was eine syntaktisch korrekte Zeichenfolge bedeutet. Eine
syntaktisch nicht korrekte Zeichenfolge -- wie z. B. $3 +$ -- ist von
vornherein bedeutungslos. Die Definition der Bedeutung syntaktisch
korrekter Zeichenfolgen bezeichnet man als die /Semantik/ der
Sprache. So definiert die Semantik der mathematischen Formelsprache
z. B., dass

+ das Operationszeichen $+$ für die Addition steht und
+ der Ausdruck $3 + 5$ äquivalent zu $8$ ist. 

Man beachte, dass dabei vorausgesetzt wird, dass die Semantik der
Addition bereits anderswo definiert ist. Die Addition natürlicher
Zahlen ist in der Mathematik z. B. durch die bekannten Peano-Axiome
definiert. Darauf soll aber hier nicht näher eingegangen werden. Wir
setzen die Wohldefiniertheit der Semantik der mathematischen Formelsprache
als gegeben voraus.

Ein wichtiger Bestandteil der Semantik der mathematischen
Formelsprache sind die Regeln, die erlauben, Teile einer Formel durch
äquivalente, einfachere Teile zu ersetzen. Beinhaltet diesen Prozess
auch das Ersetzung von Variablen durch Konstanten, bezeichnet
man ihn auch als /Auswertung/ einer Formel oder eines Ausdrucks. Dabei
werden die Ersetzungsregeln solange angewendet, bis keine weitere
Regel mehr anwendbar ist.


Aus der Mathematik wissen wir, dass die Gleichung
\begin{equation}
a\cdot a + 2ab + b\cdot b = (a + b)(a + b)
\end{equation}
gilt, das Ersetzen der linken durch die rechte Seite also eine
äquivalente Umformung darstellt. Hierbei handelt es sich aber nicht um
eine Auswertung, denn erstens werden hier die Variablen nicht durch
Konstanten ersetzt und zweitens ist auch nicht klar, welcher der beiden
Ausdrücke der einfachere ist.

Eine Auswertung könnte nun stattfinden, wenn wir danach fragen,
welchen Wert die Funktion $bf(a,b)$ hat, wenn z. B. $a$ durch $3$ und $b$
durch $4$ ersetzt werden. In der folgenden Gleichung ist diese
Ersetzung vorgenommen worden:

\begin{equation}
bf(3,4) = 3\cdot 3 + 2\cdot 3\cdot 4 + 4\cdot 4
\end{equation}

Um den Ausdruck auf der rechten Seite korrekt auswerten zu können,
müssen weitere semantische Regeln benutzt werden; hier insbesondere
die Regel: Punktrechnung geht vor Strichrechnung.

Damit könnte nun der Ausdruck wie folgt äquivalent umgeformt werden:
\begin{eqnarray}
bf(3,4) & = & 3\cdot 3 + 2\cdot 3\cdot 4 + 4\cdot 4 \\
& = & 9 +  2\cdot 3\cdot 4 + 4\cdot 4 \\
& = & 9 +  6\cdot 4 + 4\cdot 4 \\
& = & 9 + 24 + 4\cdot 4 \\
& = & 9 + 24 + 16 \\
& = & 33 + 16 \\
& = & 49
\end{eqnarray}

**** Syntax und Semantik von /FuProlang/ (vorläufig)
Funktionale Programmiersprachen zeichnen sich u. a. dadurch aus, dass
sie sich hinsichtlich ihrer Semantik sehr strikt an der Mathematik
orientieren. Das bedeutet z. B., dass die Auswertung von Ausdrücken
durch eine Folge von äquivalenten Umformungen definiert ist.

Betrachten wir dies exemplarisch anhand der Funktion $f$ aus dem
vorhergehenden Abschnitt. Die Syntax von /FuProlang/ verlangt zunächst
das wir die mathematische Funktionsdefintion
\begin{equation}
bf(a,b) = a\cdot a + 2ab + b\cdot b
\end{equation}
umschreiben. Wollen wir in /FuProlang/ eine Funktion mit Namen =f= und
den Parametern =a= und =b= definieren, sieht das so aus:
: (def bf
    :   (fn [a b] ... ))
Wollen wir nun die rechte Seite der Funktionsdefinition nach
/FuProlang/ übertragen, müssen wir die Syntaxregel von /FuProlang/
beachten, wonach Grundform eines (arithmetischen) Ausdrucks (in
                                                             /FuProlang/) immer so aussieht:
: (operator operand-1 operand-2 ... operand-n)
Damit erhalten wir die vollständige Funktionsdefinition:
#+begin_src clojure
(def bf
  (fn [a b]
    (+ (* a a)
       (* 2 a b)
       (* b b))))
#+end_src
Die Semantik von /FuProlang/ definiert nun insbesondere, wie
Ausdrücke, d. h. Funktionsanwendungen ausgewertet werden. Wie in der
mathematischen Formelsprache können durch die Anwendung einfacher
Regeln, Ausdrücke in /FuProlang/ in einfachere Ausdrücke äquivalent
umgeformt werden können. Die Frage lautet also z. B., wie aus der
Funktionsanwendung 
#+begin_src clojure
(bf 3 4)
#+end_src
das Resultat =49= entsteht.

Betrachten wir dazu eine verallgemeinerte Definition einer
Funktion =g= mit den formalen Parametern =x-1 ... x-n= und der
Berechnungsvorschrift =exp=:
: (def f
    :   (fn [x-1 ... x-n]
          :     exp))

Für die Anwendung der Funktion gilt dann die folgende Ersetzungsregel.

*Ersetzungsmodell für Funktionsanwendungen:*

+ Werte den Rumpf der Funktion aus, wobei jeder formale Parameter
durch das korrespondierende ausgewertete Argument ersetzt wird.
+ Formal: Mit =(def f (fn [x-1 ... x-n]$ exp))=
gilt: 
\begin{equation}
(f\ v_{1}\  ...\  v_{n}) = exp^{x_{i}}_{v_{i}}
\end{equation}

Dabei bedeutet
$exp^{x_{i}}_{v_{i}}$, dass in =exp= jedes Auftreten eines
$x_{i}$ in durch $v_{i}$ ersetzt ist. ($x_i$ entspricht =x-i=.)

Wenden wir diese Regel auf die Anwendung der Funktion =bf= an:
: (bf 3 4) = (+ (* 3 3)
                :               (* 2 3 4)
                :               (* 4 4))
Wie in der Mathematik gehen wir davon aus, dass die Addition und
Multiplikation auch in /FuProlang/ bereits definiert sind. D. h.,
weitere Auswertungsschritte erfolgen analog zur mathematischen
Formelsprache. Man beachte dabei, dass aufgrund der Klammerstruktur in
/FuProlang/ keine Vorrangregel für die Multiplikation und Addition
erforderlich ist:
: (bf 3 4) = (+ (* 3 3)
                :               (* 2 3 4)
                :               (* 4 4))
:          = (+ 9
                :               (* 2 3 4)
                :               (* 4 4))
:          = (+ 9
                :               24
                :               (* 4 4))
:          = (+ 9 24 16)
:          = 49

*** Fallunterscheidungen
+ Fallunterscheidungen aus der Mathematik
+ Bedingte Funktionen für Probleme, deren Lösung keine einfache Formel
darstellt
+ Vergleichsausdrücke, boolesche Ausdrücke in /FuProlang/
+ Ausdrucksmittel für Fallunterscheidungen in /FuProlang/
+ Auswertungsregeln für Fallunterscheidungen
*** Entwurfsmethodik (von der Problemdefinition zur Fallunterscheidung)
+ Identifikation von zu unterscheidenden Fällen
+ Ableitung einer /Funtkionsschablone/
+ Ausfüllen der Schablone
+ Erweiterung des Regelsatzes für den Entwurf bedingter Funktionen
** Nicht-numerische Daten
*** Symbolische Ausdrücke o. a.
+ symbols, symbolic expressions in Clojure, Racket
+ Bilder in Racket
+ Character, Strings in Haskell, Clojure, Racket F#, Python
+ elementare Funktionen auf nicht-numerischen Datentypen
*** Sequenzen
+ Definition endlicher Folgen
+ Listen
+ Aufbau
+ Erzeugung
+ Zerlegung
*** Funktionen zur Verarbeitung von Sequenzen
+ Beschreibung von Listen als endliche, beliebig lange Folgen
+ Ableitung einer bedingten Funktion zur Verarbeitung von Listen
+ Funktionsschablonen
+ natürliche Rekursion
*** Entwicklungsmethodik für sequenzenverarbeitende Funktionen
+ Erweiterung des Regelsatzes für den Entwurf bedingter Funktionen
+ Betrachtung weiterer Listenarten:
+ nicht-leere Listen
+ geschachtelte Listen
+ Funktionen für die Verarbeitung mehrerer Listen

** Datenabstraktion
*** zusammengesetzte Datenstrukturen
+ Einführung anhand einfacher Beispiele (z. B. rationale Zahlen oder
                                            Punkten in der Ebene)
+ Definition eigener Konstruktions- und Selektionsfunktionen
(z. B. auf der Basis von Listen)
+ Errichtung von Abstraktionsbarrieren (information hiding)
*** Konstruktions- und Projektionsfunktionen
+ Sprachspezifische Mittel zur Definition und Verarbeitung Verbünden (Records)
+ Umsetzung der Beispiele aus vorigem Abschnitt (rationale Zahlen,
                                                           Punkte etc.)
*** Entwicklungsmethodik für strukturverarbeitende Funktionen
+ Funktionsschablonen für Funktionen,
+ die Records verarbeiten,
+ die Records herstellen
+ Erweiterung des Regelsatzes für den Entwurf verbundverarbeitender
Funktionen
*** algebraische Datentypen (Aufzählungstypen, Produkttypen, Summentypen)
+ Records als Beispiel für Produkttypen
+ Entsprechung Produkttyp und kartesisches Produkt
+ Entsprechung Summentyp und Mengenvereinigung
+ Sprachspezifische Mittel zur Definition von
+ Aufzählungstypen
+ Summentypen (Vereinigungstypen)
+ Erweiterung des Regelsatzes für den Entwurf summentypverarbeitender
Funktionen
*** rekursive algebraische Datentypen (z. B. Bäume)
+ beliebig große Datennmengen
+ rekursive Definitionen (Rückverweis auf Listen)
+ weitere Beispiele rekursiver Datentypen
+ Baumstrukturen am Beispiel von Stammbäumen
+ Erweiterung des Regelsatzes für den Entwurf von Funktionen für die
Verarbeitung rekursiver Datentypen 
*** Natürliche Zahlen als rekursive Datenstruktur
+ Verweis auf Peano-Axiome
+ Implementierung eines rekursiven Summentyps für natürliche Zahlen
+ Anwendung der Entwurfsregeln für Funktionen über natürlichen Zahlen
*** Listen, Vektoren, Mengen, Maps, Bäume
+ Sprachspezifische Standard-Datenstrukturen
+ Erzeugung, Verarbeitung
+ Einsatzzwecke
+ Beispiele
** Erweiterung der funktionalen Abstraktion
+ Historie:
+ Infinitesimal-Rechnung (17. Jhdt. Newton, Leibniz) - Funktionen mit
Funktionen als Argument
+ 1941 Anlonzo Church: Lambda-Kalkül - Daten sind Funktionen
+ 1960 John McCarthy: Lisp - Funktionen sind Daten
+ 2014 Lambda-Ausdrücke im „Mainstream” (Java) angekommen
+ Google, Facebook, Twitter, Netflix - alle stützen sich auf
funktionale Programmierung
*** Funktionen als Argumente -- Analogie zur Summenformel der Mathematik
\begin{equation}
\sum_{i=a}^b f(i) = f(a)+ \ldots +f(b) 
\end{equation}
entspricht
#+begin_src clojure
(def sum
  (fn [term a next b]
    (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b)))))
#+end_src
Anwendungsbeispiele:
\begin{equation}
\sum_{x=1}^5 x^3 
\end{equation}
entspricht
#+begin_src clojure
(def cube (fn [x] (* x x x)))
(sum cube 1 inc 5)
#+end_src
\begin{equation}
\sum_{i=1}^{10} i 
\end{equation}
entspricht
#+begin_src clojure
(def identity (fn [x] x))
(sum identity 1 inc 10)
#+end_src
weitere Beispiele: Integrale
*** Nutzung anonymer Funktionen (Lambda-Ausdrücke)
+ Lambda-Ausdrücke (=fn=-Ausdrücke) bereits eingeführt im Abschnitt
  /Funktionale Abstraktion/
+ Beispiele aus dem vorigen Abschnitt:
#+begin_src clojure
(sum (fn [x] (* x x x)) 1 (fn [i] (+ i 1)) 5)
#+end_src
oder
#+begin_src clojure
(sum (fn [x] x) 1 (fn [i] (+ i 1)) 10)
#+end_src
*** Einführung lokaler Variablen
+ Benennung eines Wertes/Ausdrucks
  + zur Vermeidung von Mehrfachberechnungen
  + Steigerung der Lesbarkeit
+ lokale Hilfsfunktionen (Vermeidung der Verunreinigung von Namensräumen)
*** „klassische” Funktionen höherer Ordnung
... für die Verarbeitung von Listen/Sequenzen
+ Herleitung/Motivation: Befolgung der Regeln zum Entwurf von
  Funktionen liefert immer wieder sehr ähnliche Funktionen
+ Abstraktion liegt auf der Hand
+ =filter=
+ =map=
+ =reduce=

** Ersetzungsmodell für Funktionsanwendungen
*** Klärung der Begriffe Syntax und Semantik
+ Wiederholung aus Abschnitt /Syntax und Semantik von FuProlang (vorläufig)/
+ Vervollständigung/Präzisierung des Ersetzungsmodell
*** Regelbasierte Auswertung von Funktionsanwendungen -- elementare Algebra (äquivalente Umformungen)
+ Ergänzung der Regeln für /Pseudofunktionen/
  + =cond=, =fn=
  + Einführung des Umgebungsbegriffs, =def=
*** Korrektheit von Funktionen
+ Beweisführung durch rekursive Induktion

** Integration von Daten und Funktionen -- Einführung des Objektbegriffs
*** Funktionen als Resultate von Funktionen
+ Einstieg mit einfachen Funktionen, die Funktion liefern
*** [[http://www.ccs.neu.edu/home/matthias/Presentations/ecoop2004.pdf][funktionale Objekte]] (non-mutable objects)
+ Objekte sind Maps
+ Objekte als Closures
  + :(def add (fn [n] (fn [m] (+ n m))))
+ Erzeugung eines Objektes liefert Dispatcher-Funktion
+ Dispatcher-Funktion ordnet Nachrichten Methoden (Functions) zu
*** Zustandsänderungen / Zuweisungen
/eventuell streichen/
*** Änderbare Objekte
/eventuell streichen/
    
* Footnotes

[fn:1] /FuProLang/ ist der generische Name für eine noch auszuwählende
funktionale Programmiersprache.

[fn:2] /FuProlang/ benutzt -- wie fast alle bekannten
Programmiersprachen -- den Dezimalpunkt statt des Dezimalkommas.

[fn:3] „fn-Ausdrücke” werden in der Literatur häufig als
Lambda-Ausdrücke bezeichnet. Dazu später mehr.

[fn:4] Hinweise zur Benutzung der Repl finden Sie im [[*Anhang][Anhang]].

[fn:5] Zu den Wahrheitswerten und dem Operator „=” vergleiche
Abschnitt [[*Ausdrücke in /FuProLang/ (2)][Ausdrücke in /FuProLang/ (2)]]

* Anhang
** Benutzung der Clojure-Repl
** Benutzung der F#-Repl
** Benutzung der Haskell-Repl
** Weitere ... ?
** local Lentic vars
