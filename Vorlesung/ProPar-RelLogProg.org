# +SETUPFILE: /Users/johannes/Documents/myOrg/org-html-themes/setup/theme-bigblow.setup
#+SETUPFILE: ./theme-bigblow-local.setup
#+TITLE: Relational-logische Programmierung
#+SUBTITLE: Programmierparadigmen
#+AUTHOR: Johannes Brauer
#+OPTIONS:   H:4
#+OPTIONS: num:nil d:nil
#+OPTIONS: toc:nil
#+OPTIONS: reveal_single_file:nil
#+Language:  de
#+STARTUP: latexpreview
#+STARTUP: inlineimages
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="mycss/mystyle.css" />
#+REVEAL_THEME: simple
#+REVEAL_TRANS: slide
#+REVEAL_HLEVEL: 1
#+REVEAL_INIT_SCRIPT: dependencies: [ { src: 'plugin/menu/menu.js', async: true },
#+REVEAL_INIT_SCRIPT:                 { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true } ]
#+REVEAL_MARGIN: 0.05
#+REVEAL_EXTRA_CSS: ./mycss/myrevealstyle.css
#+OPTIONS: reveal_control:t

* Einführung
+ Relational-logische Programmierung: Programme spezifizieren
  Relationen zwischen Größen.
+ Logische Programmierung: Programm mit Datenstrukturen: Listen,
  Binärbäume, symbolische Ausdrücke, natürliche Zahlen.
+ Der Ursprung der logischen Programmierung: automatische Theorembeweiser.
+ Sie verlangt eine Änderung der Denkweise:
  1. Strukturierte logische Formeln werden als Relations- (Prozedur-)
     Spezifikationen betrachtet.
  2. Eine Frage zu einer logischen Implikation wird als Relations-
     (Prozedur-) Aufruf betrachtet.
  3. Der Beweis der Implikation ist dann die Berechnung der Antwort.

#+Reveal: split

+ Konkreter: Ein Axiom der Form:\\
  =A if B1 and B2 ... and Bn=\\
  kann als Prozedur in einer Programmiersprache betrachtet werden:
  + =A= ist der Prozedurkopf,
  + die =Bis= bilden ihren Rumpf.
+ Der Versuch =A= zu lösen, wird als Ausführung der Prozedur
  verstanden. Dazu muss der Ausdruck =B1 and B2 ... and Bn= gelöst
  bzw. ausgeführt werden.

* Relationale Programmierung mit Prolog
+ Prolog (Programming in Logic) wurde Anfang der 1970er Jahre von dem
  französischen Informatiker Alain Colmerauer entwickelt.
+ Prolog hat sich als Programmiersprache über die strikte logische
  Basis hinaus entwickelt: Praktische Programmierkonstrukte wie
  arithmetische Operationen, Optimierungshilfmittel und Ein-/Ausgabe
  sind hinzugekommen.
+ Die Darstellungen in den folgenden Abschnitten basieren auf
  cite:Bramer2013 und  cite:Clocksin2003.

** Syntax und Semantik relational-logischer Programme
+ Die Syntax basiert auf einer Teilmenge der Prädikatenkalküls. Ein
 relational-logisches Programm besteht aus einer Menge von Formeln,
  die nach Fakten und Regel unterschieden werden. Beide beschreiben
  bekannte Relationen auf der Problemdomäne.
+ Die Semantik besteht in einer Menge von Antworten auf Fragen.
+ Ein Programm wird ausgeführt durch eine logische Aussage, die auch
  Frage oder /Zielausdruck/ (oder goal oder query) genannt wird.
+ Fragen können Variablen enthalten.
+ Die Beantwortung von Fragen mit Variablen besteht darin,
  Variablenbindungen zu finden, die die Frage „beweisen“.
+ Dies geschieht mithilfe zweier Techniken:
  + Unifikation: Belegung von Variablen in zwei Termen, so dass diese
    gleich werden.
  + Backtracking: Suchstrategie bei der Beweisfindung.
+ Es gibt nur eine primitive Operation: den Unifikationsoperator
  ~=~.
+ Es gibt keine Typen.
** Einstiegsbeispiel
+ Das „Hallo Welt“-Äquivalent für ein Prolog-Programm ist meistens
  eine Wissensdatenbank mit Verwandtschaftsverhältnissen.
  + Eltern: Paul, Elfriede
  + Kinder: Klaus, Claudia, Monika
+ Fakten in Prolog:
  #+BEGIN_SRC prolog
  vater(klaus, paul).
  vater(claudia, paul).
  vater(monika, paul).
  mutter(klaus, elfriede).
  mutter(claudia, elfriede).
  mutter(monika, elfriede).
  verheiratet(paul, elfriede).
  #+END_SRC

*** Start des Prolog-Interpreters
+ Im folgenden wird [[http://www.swi-prolog.org][SWI-Prolog]] benutzt.
+ Nach dem Start des Interpreters und der Konsultation der Faktendatei
  =stammbaum.pl= können Fragen an den Interpreter gestellt werden:
#+BEGIN_SRC prolog
Welcome to SWI-Prolog (threaded, 64 bits, version 7.4.2)
SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.
Please run ?- license. for legal details.

For online help and background, visit http://www.swi-prolog.org
For built-in help, use ?- help(Topic). or ?- apropos(Word).

1 ?- consult('stammbaum.pl').
true.

2 ?- vater(klaus, paul).
true.

3 ?- mutter(claudia, paul).
false.
#+END_SRC
*** Weitere Beispiele für Fragen (Zielausdrücke, goals):
Fragen können Variablen benutzen, die stets mit einem Großbuchstaben
beginnen müssen.
#+BEGIN_SRC prolog
?-  mutter(klaus, elfriede).
    true.
?-  vater(claudia, X).
    X=paul.
?-  vater(peter, X).
    false.
?-  vater(X, paul).
    X=klaus;
    X=claudia;
    X=monika.
?-  verheiratet(X, Y).
    X=paul;
    Y=elfriede.
#+END_SRC
*** Regeln
Nehmen wir an, wir möchten auch Anfragen über die
Schwesterbeziehung in die Datenbasis aufnehmen, um entsprechende
Anfragen beantworten zu können. Dann hat man zwei Möglichkeiten:

1. Neue Fakten hinzufügen:
   #+begin_small
   #+BEGIN_SRC prolog
   schwester(claudia, monika).
   schwester(monika, claudia).
   schwester(klaus, claudia).
   schwester(klaus, monika).
   #+END_SRC
   #+end_small

2. Formulierung einer Regel: =Y= ist Schwester von =X=, falls =Y= 
   weiblich und Mutter von =X= gleich Mutter von =Y= ist und Vater von
   =X= gleich Vater von =Y=.\\
   \\
   Dann muss man nur noch als Fakten festhalten, welche
   Familienmitglieder weiblich sind. Die Regel erlaubt es, aus bekannten 
   Fakten neue herzuleiten!

*** Prolog-Programm mit Schwesterregel

Fakten:
#+BEGIN_SRC prolog
vater(klaus, paul).
vater(claudia, paul).
vater(monika, paul).
mutter(klaus, elfriede).
mutter(claudia, elfriede).
mutter(monika, elfriede).
verheiratet(paul, elfriede).
weiblich(claudia).
weiblich(monika).
weiblich(elfriede).
#+END_SRC

Regeln:
#+begin_small
#+BEGIN_SRC prolog
schwester(X, Y):- weiblich(Y), 
       mutter(X, Z), mutter(Y, Z), 
       vater(X, W), vater(Y, W),
       X \== Y.
#+END_SRC
#+end_small

*** Beispielanfragen

#+begin_smaller
#+BEGIN_SRC prolog
?- schwester(klaus, claudia).
#+END_SRC
#+end_smaller

Das Prolog-System muss

1. prüfen, ob =claudia= weiblich ist (Faktum)
2. erkennen, dass =mutter(klaus,Z)= und =mutter(claudia,Z)= gelten für
   =Z=elfriede=
3. erkennen, dass =vater(klaus,W)= und =vater(claudia,W)= gelten für
   =W=Paul=
4. daher =true= ausgeben

#+Reveal: split

#+begin_smaller 
#+BEGIN_SRC prolog
?- schwester(klaus, X).
#+END_SRC
#+end_smaller

-  Die Frage bedeutet: Wer sind die Schwestern von Klaus?
-  Das Prolog-System durchsucht seine Datenbank von Fakten (und Regeln)
   in fester Reihenfolge; nämlich:
   1. von oben nach unten
   2. von links nach rechts
-  Daher liefert die Anfrage die Antwort:

   #+begin_small
   #+BEGIN_SRC prolog
   X=claudia;
   X=monika;
   false.
   #+END_SRC
   #+end_small

#+Reveal: split

#+begin_smaller
#+BEGIN_SRC prolog
?- schwester(X, Y).
#+END_SRC
#+end_smaller

Es ist nicht schwer zu sehen, dass aufgrund der o.g. Auswertestrategie
folgende Ausgabe erzeugt wird:

#+begin_small
#+BEGIN_SRC prolog
X = klaus, Y = claudia ;
X = monika, Y = claudia ;
X = klaus, Y = monika ;
X = claudia, Y = monika ;
false.
#+END_SRC
#+end_small

** Basiskonzepte von Prolog
*** Terme
+ Alle Daten (einschließlich der Prolog-Programme) in Prolog werden
  durch /Terme/ repräsentiert.
+ Ein Term ist:
  + ein /Atom/. Beispiele sind =elmshorn=, =claudia=. Atome beginnen
    mit einem Kleinbuchstaben.
  + eine /Variable/. Variablen beginnen mit einem Großbuchstaben oder
    dem Unterstrich. Ein singulärer Unterstrich bezeichnet die
    /anonyme Variable/, die für „irgendeinen Term” steht.
  + eine /Ganzzahl/ oder eine /Gleitkommazahl/.
  + ein /zusammengesetzter Term/ (compound term):
    + Wenn $t_1, t_2, \ldots ,t_n$ Terme sind, dann ist auch $f(t_1,
      t_2, \ldots ,t_n)$ ein Term. $f$ heißt Funktor und $n$ ist die
      Stelligkeit des zusammengesetzten Terms.\\
      Beispiele: =f(a)=, =g(f(X))=, =+(a, f(X))=
*** Programme
+ Ein Prolog-Programm besteht aus einer Menge von Prädikaten.
+ Prädikate beschreiben Relationen zwischen ihren Argumenten. Logisch
  betrachtet beschreibt ein Prolog-Programm, was gilt.
+ Jedes /Prädikat/
  + besitzt ein Atom als Namen und beliebig viele Argumente.
  + Jedes Argument ist ein Prolog-Term.
  + Ein Prädikat mit dem Namen =Pred= und $n$ Argumenten wird durch
    einen Prädikatsindikator notiert: =Pred/n=. $n$ ist die
    Stelligkeit des Prädikats.
  + Ein Prädikat wird durch eine Menge von /Klauseln/ (s. u.) definiert.
  + Die Klauseln, die ein Prädikat definieren, stellen logische
    Alternativen dar. Wenn eine der Klauseln wahr ist, ist das ganze
    Prädikat war.
*** Klauseln -- Regeln
+ Ein Klausel ist entweder ein /Fakt/ oder eine /Regel/.
+ Eine Regel hat die Form:\\
  =Kopf :- Rumpf.=
  + Die Form des =Kopf= hängt von der Zahl der Argumente des Prädikats
    ab:
    + Besitzt das Prädikat keine Argumente, dann besteht der =Kopf=
      nur aus dem Namen des Prädikats, ist also ein Atom.
    + Andernfalls ist =Kopf= ein zusammengesetzter Term, z. B.:\\
      =schwester(X, Y)=
  + Der =Rumpf= hat die Form: $B_1,\ldots,B_n$, wobei die $B_i$ Terme
    sind, die mit dem Komma konjunktiv verknüpft sind.
  + Die Zeichenfolge =:-= steht für die logische Implikation,
    gerichtet vom Rumpf zum Kopf.
#+Reveal: split
  + Z. B. kann die Regel\\
    : father(Dad, Child) :- parent(Dad, Child), male(Dad).
    wie folgt gelesen werden: =Dad= (eine Variable) ist =father= von
    =Child= (Variable), wenn =Dad= =parent= von =Child= und =Dad=
    =male= ist.
*** Klauseln -- Fakten
+ Ein Faktum wird so aufgeschrieben:\\
  =Kopf.=
+ Dieser Ausdruck ist äquivalent zur Regel:\\
  =Kopf :- true.=
+ Logisch bedeutet das, dass die Regel immer wahr ist, weil das
  Standardprädikat =true/0= immer wahr ist.
*** Starten von Prolog-Programmen 
+ Eingabe von Fragen/Zielausdrücken (queries) am Eingabeprompt des
  Prolog-Interpreters
+ Ein Zielausdruck besteht aus dem Namen eines beliebigen Prädikats
  und seiner Argumente.
+ Eine Frage kann aus der Und-Verknüpfung von mehreren Zielausdrücken
  bestehen. 
+ In einer Frage sind Variabeln existenz-quantifiziert. Eine Frage
  =p(X)= kann so gelesen werden: Existiert eine Variablenbindung für
  X, so dass =p(X)= wahr wird.
+ Wenn eine passende Variablenbindung gefunden werden kann (the goal
  succeeds), antwortet der Interpreter mit einem logisch äquivalenten
  Zielausdruck.
+ Wenn eine Frage mehrere Antworten hat, liefert der Interpreter die
  übrigen auf besondere Anforderung (in SWI-Prolog durch Eingabe von
  Leerzeichen oder Semikolon).

*** Ausführung von Prolog-Programmen
Die operationale Semantik von Prolog
+ Die Ausführung von Prolog-Code kann als ein Spezialfall einer
  /Resolution/ betrachtet werden.
+ Die Resolution ist ein Verfahren der formalen Logik, um die
  Gültigkeit einer logischen Formel zu prüfen. Dabei wird versucht,
  aus der Verneinung der Frage einen Widerspruch abzuleiten.
+ Wenn ein Widerspruch gefunden wird, ist die Frage die logische
  Folgerung aus dem Programm.
+ Ein wichtiger Schritt in diesem Prozess ist die Unifikation von
  Termen.
+ Wird der Kopf einer Klausel für die Unifikation mit einem
  Zielausdruck ausgewählt, wird diese auf die Argumente von beiden
  Termen angewendet.
+ Daraus folgt, dass es in Prolog keine Unterscheidung zwischen Ein-
  und Ausgabeparametern gibt.
  (Vgl. [[file:ProPar-RelProgUebrscht.org::*Beispiel:%20Nat%C3%BCrliche%20Zahlen][Implementierung von natürlichen Zahlen]]!)
#+Reveal: split
+ Sind die Köpfe mehrerer Klauseln mit einem Zielausdruck
  unifizierbar, werden die Alternativen durch /Backtracking/
  abgearbeitet.
+ Informell kann die Ausführungsstrategie von Prolog als Tiefensuche
  (depth-first search) mit /chronologischem Backtracking/ betrachtet werden.

*** Standardprädikate
+ Es gibt einige vordefinierte Standardprädikate, z. B.
  + ~=/2~ ist wahr, wenn seine Argumente unifizierbar sind;
  + =true/0= ist immer wahr, =false/0= immer falsch;
  + =dif/2= is wahr genau dann, wenn die Argumente unterschiedliche
    Terme sind;
  + =,/2= bezeichnet die Konjunktion, =;/2= die Disjunktion.
+ Standardprädikate für den Vergleich Zahlen (alle zweistellig):
  + ~=:=~, ~=\=~ numerische Gleichheit, Ungleichheit
  + =<=, =>=, ~=<~, ~>=~
+ Arithmetische Operationen (alle zweistellig):\\
  =+ - * / // mod=\\
  Es gelten die üblichen Vorrangregeln.
+ Die Standardprädikate für Zahlen können in Infixnotation geschrieben
  werden, also =3 + 4= anstatt =+(3, 4)=.
#+Reveal: split
+ Beachte: Der Unifikationsoperator ~=/2~ bewirkt keine Auswertung
  arithmetischer Ausdrücke, dafür steht der Operator =is/2= zur
  Verfügung:
  #+begin_smaller
  #+BEGIN_SRC prolog
  ?- X = 3 + 4.
  X = 3+4.
  ?- X is 3+4.
  X = 7.
  #+END_SRC
  #+end_smaller
  
*** Resolution / Backtracking
+ Resolution: Grundlage für eine automatische Beweisführung
+ basiert auf dem Prinzip der Unifikation und des automatischen
  Rücksetzens (Backtracking).
+ Prolog benutzt Tiefensuche; Reihenfolge der Klauseln entscheidend
+ Teilziele einer Anfrage werden von links nach rechts bearbeitet.
+ Zu jedem Teilziel wird die im Programmtext erste Klausel ausgewählt
  und versucht mit dem Teilziel zu unifizieren. 
+ Ist die Klausel eine Regel, so wird das Teilziel durch den
  Regelrumpf ersetzt und versucht zu beweisen. Andernfalls wird
  versucht das nächste Ziel der Anfrage herzuleiten. 
+ Tritt während der Resolution ein Fehler bei der Unifikation auf,
  wird also keine passende Programmklausel gefunden, so springt das
  PROLOG-System durch das eingebaute Rücksetzen auf den letzten Punkt
  zurück, an dem eine Entscheidung getroffen wurde, hebt die an dieser
  Stelle gemachten Variablenbindungen auf und wählt die nächste
  alternative Klausel aus.
**** Beispiel
#+BEGIN_SRC prolog
father(abraham,isaac).
father(haran,lot).
father(haran,milcah).
father(haran,yiscah).
male(isaac).
male(lot).
female(milcah).
female(yiscah).
son(X,Y) :- father(Y,X), male(X).
daughter(X,Y) :- father(Y,X), female(X).
#+END_SRC
Nachfolgend wird die Resolution der Anfrage
: daughter(X,haran).
gezeigt.
#+Reveal: split
1. Prolog sucht passende Programmklausel\\
   Unifikation =daughter(X,Y)= und =daughter(X,haran)= \\
   $\rightarrow$ Substitution =Y=haran=
2. Das ursprüngliche Ziel wird durch den Regelrumpf ersetzt\\
   $\rightarrow$ neue Zielanfrage: =father(haran,X), female(X).=
3. linkes Teilziel wird ausgewählt: =father(haran,X)=\\
   erste Programmklausel wird ausgewählt: =father(abraham,isaac).=\\
   $\rightarrow$ Unifikation nicht möglich $\rightarrow$ Backtracking
4. nächste alternative Programmklausel wird ausgewählt: =father(haran,lot)=\\
   $\rightarrow$ Substitution =X=lot=
5. rechtes Teilziel wird ausgewählt und Substitution angewendet: =female(lot)=\\
   $\rightarrow$ keine passende Programmklausel vorhanden $\rightarrow$ Backtracking
#+Reveal: split
6. [@6]Substitution =X=lot= wird aufgehoben, nächste Klausel im
   Programmtext ausgewählt: =father(haran,milcah)= \\
   $\rightarrow$ Substitution =X=milcah=
7. rechtes Teilziel wird ausgewählt und Substitution angewendet:
   =female(milcah)=\\
   $\rightarrow$ passende Programmklausel vorhanden
   $\rightarrow$ Prolog gibt die Substitution =X=milcah= aus
8. Durch Eingabe von =;= wird manuell Backtracking erzwungen um
   alternative Lösungen zu finden 
9. Substitution =X=milcah= wird aufgehoben, nächste Klausel im
   Programmtext ausgewählt: =father(haran,yiscah)= \\
   $\rightarrow$ Substitution =X=yiscah=
10. rechtes Teilziel wird ausgewählt und Substitution angewendet:\\
    =female(yiscah)= \\
    $\rightarrow$ passende Programmklausel vorhanden\\
    $\rightarrow$ Prolog gibt die Substitution =X=yiscah.= aus und
    schließt die Beantwortung der ursprünglichen Anfrage, da
    keine Alternativen mehr vorhanden sind 
* Literatur
* bibliography:referenzen.bib
