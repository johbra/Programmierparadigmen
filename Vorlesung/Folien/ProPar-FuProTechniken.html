<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<title>Funktionale Programmierung &#x2013; Techniken</title>
<meta name="author" content="(Johannes Brauer)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="./mycss/myrevealstyle.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="stylesheet" type="text/css" href="mycss/mystyle.css" />
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Funktionale Programmierung &#x2013; Techniken</h1><h2 class="author">Johannes Brauer</h2><p class="date">Created: 2017-12-16 Sat 17:41</p>
</section>

<section>
<section id="slide-orgf18a21d">
<h2 id="orgf18a21d">Anwendung von Entwurfsvorschrift V auf zwei Listen</h2>
<div class="outline-text-2" id="text-orgf18a21d">
</div>
</section>
<section id="slide-org96f9799">
<h3 id="org96f9799">Drei Fälle</h3>
<ol>
<li>Ein Argument kann atomar behandelt werden, d.h. eine Liste muss nicht
zerlegt werden.</li>
<li>Beide Listen sind im Gleichschritt zu verarbeiten.</li>
<li>Bei beiden Listen ist für die Ermittlung des Resultats der Zugriff
auf das erste Element und die Restliste notwendig.</li>

</ol>

<p>
Behandlung der drei Fälle:
</p>

<ol>
<li>EV V wird wörtlich angewendet, weil das zweite Argument nicht
zerlegt werden muss. Beispiel: append (concatenate).</li>
<li><p>
Da beide Listen gleich lang sind, genügt es, eine von beiden auf
Leersein zu prüfen. Für die Ermittlung des Resultats ist aber der
Zugriff auf das erste Element und die Restliste von beiden
Argumentlisten notwendig.
</p>

<p>
Das führt zur folgenden angepassten Funktionsschablone:
</p></li>

</ol>

</section>
<section id="slide-org739e350">
<h3 id="org739e350">Funktionsschablone für Fall 2</h3>
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">listen-funktion</span>
       <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lst1 lst2<span style="color: #909183;">]</span>
          <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
             <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lst1<span style="color: #709870;">)</span> ...
             <span style="color: #D0372D;">:else</span> ... <span style="color: #709870;">(</span><span style="color: #006FE0;">first</span> lst1<span style="color: #709870;">)</span> ... <span style="color: #709870;">(</span><span style="color: #006FE0;">first</span> lst2<span style="color: #709870;">)</span>
<span style="color: #8D8D84;">;;                                      </span><span style="color: #8D8D84; font-style: italic;">===========  </span>
                 ... <span style="color: #709870;">(</span>listen-funktion 
                      <span style="color: #907373;">(</span><span style="color: #006FE0;">rest</span> lst1<span style="color: #907373;">)</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">rest</span> lst2<span style="color: #907373;">)</span><span style="color: #709870;">)</span> ...<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;;                                </span><span style="color: #8D8D84; font-style: italic;">===========</span></pre>
</pre>
</div>

</section>
<section id="slide-org5761780">
<h3 id="org5761780">Behandlung von Fall 3</h3>
<p>
Es gibt keine nutzbare Abhängigkeit
der beiden Parameter. Hier müssen grundsätzlich alle (vier) Fälle
berücksichtigt werden:
</p>

<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">listen-funktion</span>
       <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lst1 lst2<span style="color: #909183;">]</span>
          <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
             <span style="color: #709870;">(</span><span style="color: #0000FF;">and</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">empty?</span> lst1<span style="color: #907373;">)</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">empty?</span> lst2<span style="color: #907373;">)</span><span style="color: #709870;">)</span> ...
             <span style="color: #709870;">(</span><span style="color: #0000FF;">and</span> <span style="color: #907373;">(</span>pair? lst1<span style="color: #907373;">)</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">empty?</span> lst2<span style="color: #907373;">)</span><span style="color: #709870;">)</span> 
              ... <span style="color: #709870;">(</span><span style="color: #006FE0;">first</span> lst1<span style="color: #709870;">)</span> ... <span style="color: #709870;">(</span><span style="color: #006FE0;">rest</span> lst1<span style="color: #709870;">)</span> ...
             <span style="color: #709870;">(</span><span style="color: #0000FF;">and</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">empty?</span> lst1<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>pair? lst2<span style="color: #907373;">)</span><span style="color: #709870;">)</span> 
              ... <span style="color: #709870;">(</span><span style="color: #006FE0;">first</span> lst2<span style="color: #709870;">)</span> ... <span style="color: #709870;">(</span><span style="color: #006FE0;">rest</span> lst2<span style="color: #709870;">)</span> ...
             <span style="color: #709870;">(</span><span style="color: #0000FF;">and</span> <span style="color: #907373;">(</span>pair? lst1<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>pair? lst2<span style="color: #907373;">)</span>
              ... <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lst1<span style="color: #907373;">)</span> ... <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lst2<span style="color: #907373;">)</span> ...
              ... <span style="color: #907373;">(</span><span style="color: #006FE0;">rest</span> lst1<span style="color: #907373;">)</span>  ... <span style="color: #907373;">(</span><span style="color: #006FE0;">rest</span> lst2<span style="color: #907373;">)</span><span style="color: #709870;">)</span> ...<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</section>
<section id="slide-org0851424">
<h3 id="org0851424">Drei mögliche Rekursionsschemata</h3>
<p>
Man beachte, dass die Schablone noch keine rekursiven Aufrufe
enthält. Nur für den Fall, dass beide Argumente nicht leer sind, ist
eine Rekursion möglich.
</p>

<p>
Hier sind aber drei Varianten denkbar:
</p>

<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span>listen-funktion lst1 <span style="color: #7388D6;">(</span><span style="color: #006FE0;">rest</span> lst2<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
        <span style="color: #707183;">(</span>listen-funktion <span style="color: #7388D6;">(</span><span style="color: #006FE0;">rest</span> lst1<span style="color: #7388D6;">)</span> lst2<span style="color: #707183;">)</span>
        <span style="color: #707183;">(</span>listen-funktion <span style="color: #7388D6;">(</span><span style="color: #006FE0;">rest</span> lst1<span style="color: #7388D6;">)</span> <span style="color: #7388D6;">(</span><span style="color: #006FE0;">rest</span> lst2<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
        </pre>
</pre>
</div>

</div>

<p>
Welche in Betracht kommt, kann nur nach weiterer Problemanalyse
entschieden werden.
</p>

</section>
</section>
<section>
<section id="slide-org0c34b3a">
<h2 id="org0c34b3a">Lokale Definitionen</h2>
<div class="outline-text-2" id="text-org0c34b3a">
</div>
</section>
<section id="slide-org34ff636">
<h3 id="org34ff636">Ineffiziente Funktion <code>sumprod</code></h3>
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">berechnet eine zweielementige Liste bestehend </span>
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">aus der Summe und dem Produkt der Elemente der </span>
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Zahlenliste  </span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">sumprod</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lon<span style="color: #909183;">]</span>
        <span style="color: #909183;">{</span><span style="color: #D0372D;">:pre</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? lon<span style="color: #907373;">)</span><span style="color: #709870;">]</span>
         <span style="color: #D0372D;">:post</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? <span style="color: #BA36A5;">%</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span><span style="color: #909183;">}</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lon<span style="color: #709870;">)</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">list</span> 0 1<span style="color: #709870;">)</span>
          <span style="color: #D0372D;">:else</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">list</span> 
           <span style="color: #907373;">(</span>+ <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #6276BA;">)</span> 
              <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> <span style="color: #858580;">(</span>sumprod <span style="color: #80A880;">(</span><span style="color: #006FE0;">rest</span> lon<span style="color: #80A880;">)</span><span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">)</span>
           <span style="color: #907373;">(</span>* <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #6276BA;">)</span> 
              <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> <span style="color: #858580;">(</span><span style="color: #006FE0;">rest</span> <span style="color: #80A880;">(</span>sumprod <span style="color: #887070;">(</span><span style="color: #006FE0;">rest</span> lon<span style="color: #887070;">)</span><span style="color: #80A880;">)</span><span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>
<p>
<b>Warum ist die Funktion ineffizient?</b>
</p>

</section>
<section id="slide-org5dffac9">
<h3 id="org5dffac9">Verwendung einer <i>lokalen Definition</i></h3>
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">berechnet ... </span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">sumprod</span> 
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lon<span style="color: #909183;">]</span> 
        <span style="color: #909183;">{</span><span style="color: #D0372D;">:pre</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? lon<span style="color: #907373;">)</span><span style="color: #709870;">]</span>
         <span style="color: #D0372D;">:post</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? <span style="color: #BA36A5;">%</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span><span style="color: #909183;">}</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lon<span style="color: #709870;">)</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">list</span> 0 1<span style="color: #709870;">)</span>
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span><span style="color: #0000FF;">let</span> <span style="color: #907373;">[</span>sp <span style="color: #6276BA;">(</span>sumprod <span style="color: #858580;">(</span><span style="color: #006FE0;">rest</span> lon<span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">]</span>
<span style="color: #8D8D84;">;;               </span><span style="color: #8D8D84; font-style: italic;">===  ==</span>
                  <span style="color: #907373;">(</span><span style="color: #006FE0;">list</span> 
                   <span style="color: #6276BA;">(</span>+ <span style="color: #858580;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #858580;">)</span> 
                      <span style="color: #858580;">(</span><span style="color: #006FE0;">first</span> sp<span style="color: #858580;">)</span><span style="color: #6276BA;">)</span>
<span style="color: #8D8D84;">;;                           </span><span style="color: #8D8D84; font-style: italic;">==</span>
                   <span style="color: #6276BA;">(</span>* <span style="color: #858580;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #858580;">)</span> 
                      <span style="color: #858580;">(</span><span style="color: #006FE0;">first</span> <span style="color: #80A880;">(</span><span style="color: #006FE0;">rest</span> sp<span style="color: #80A880;">)</span><span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;;                                 </span><span style="color: #8D8D84; font-style: italic;">==</span></pre>
</pre>
</div>
<p>
Lokale Definitionen dienen (u.a.) zur Benennung des Wertes eines
Ausdrucks zum Zweck der Vermeidung von Mehrfachberechnungen.
</p>

</section>
<section id="slide-org6a0f87d">
<h3 id="org6a0f87d">Syntax und Semantik von <code>let</code></h3>
<ul>
<li><p>
Die Syntax der Anwendung der Pseudofunktion <code>let</code>, ein sogenannter
<code>let</code>-Ausdruck, hat die folgende Form:
</p>

<p>
<code>(let</code> \([v_{1}\ e_{1}\ldots v_{n}\ e_{n}]\) <code>exp)</code>
</p></li>

<li>Dabei sind
<ul>
<li>die \(v_{i}\) Variablenbezeichner,</li>
<li>die \(e_{i}\) Ausdrücke sowie</li>
<li>\(exp\), der <i>Rumpf</i> des <code>let</code>-Ausdrucks, ebenfalls ein Ausdruck.</li>

</ul></li>
<li>Semantik informell: Der Wert eines <code>let</code>-Ausdrucks ist der Wert, der
sich aus der Auswertung seines Rumpfes ergibt, wenn alle darin
vorkommenden \(v_{i}\) durch die Werte der korrespondierenden \(e_{i}\)
ersetzt werden.</li>

</ul>
</section>
<section >
<ul>
<li>Für die formale Definition der Semantik genügt es hier festzuhalten,
dass der Ausdruck<br />
<code>(let</code> \([v_{1}\ e_{1}\ldots v_{n}\ e_{n}]\) <code>exp)</code><br />
durch den folgenden <code>fn</code>-Ausdruck ersetzt werden kann:<br />
<code>((fn</code> \([v_{1}\ \ldots\ v_{n}]\) <code>exp)</code> \(e_{1} \ldots e_{n})\)</li>
<li><code>let</code> ist „syntaktischer Zucker”.</li>

</ul>

</section>
<section id="slide-orgf63f084">
<h3 id="orgf63f084">Pragmatik von <code>let</code></h3>
<ul>
<li>Einen Anwendungszweck von <code>let</code> haben wir in der Funktion <code>sumprod</code>
bereits gesehen: Benennung eines Zwischenergebnisses zur Vermeidung
von Mehrfachberechnungen.</li>
<li><p>
Die Benennung von Werten kann ein Programm besser lesbar machen:
</p>
<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">berechnet \ldots  </span>
       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">sumprod</span>
         <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lon<span style="color: #909183;">]</span>
           <span style="color: #909183;">{</span><span style="color: #D0372D;">:pre</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? lon<span style="color: #907373;">)</span><span style="color: #709870;">]</span>
            <span style="color: #D0372D;">:post</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? <span style="color: #BA36A5;">%</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span><span style="color: #909183;">}</span>
           <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
             <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lon<span style="color: #709870;">)</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">list</span> 0 1<span style="color: #709870;">)</span>
             <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span><span style="color: #0000FF;">let</span> <span style="color: #907373;">[</span>sp          <span style="color: #6276BA;">(</span>sumprod <span style="color: #858580;">(</span><span style="color: #006FE0;">rest</span> lon<span style="color: #858580;">)</span><span style="color: #6276BA;">)</span>
                         restsumme   <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> sp<span style="color: #6276BA;">)</span>
                         restprodukt <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> <span style="color: #858580;">(</span><span style="color: #006FE0;">rest</span> sp<span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">]</span>
                     <span style="color: #907373;">(</span><span style="color: #006FE0;">list</span> 
                      <span style="color: #6276BA;">(</span>+ <span style="color: #858580;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #858580;">)</span> restsumme<span style="color: #6276BA;">)</span>
                      <span style="color: #6276BA;">(</span>* <span style="color: #858580;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #858580;">)</span> restprodukt<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div></li>

</ul>

</section>
<section id="slide-org6b8699c">
<h3 id="org6b8699c">Gültigkeitsbereich der durch <code>let</code> definierten Bezeichner</h3>
<ul>
<li><p>
Die Variablen \(v_{i}\) in einem <code>let</code>-Ausdruck
</p>

<p>
<code>(let</code> \([v_{1}\ e_{1}\ldots v_{n}\ e_{n}]\) <code>exp)</code>
</p>

<p>
sind im Rumpf \(exp\) sichtbar.
</p></li>

<li>Außerdem sind in \(e_{i}\) alle \(v_{j}\) mit \(j < i\) sichtbar.</li>

<li>\(v_{i}\) kann aber nicht in \(e_{i}\) verwendet werden.</li>

<li>Damit können mithilfe von <code>let</code> keine rekursiven Funktionen definiert
werden.</li>

<li>Für diesen Zweck existiert die Pseudofunktion <code>letfn</code> (s. u.).</li>

</ul>

</section>
<section id="slide-orgdcff2c3">
<h3 id="orgdcff2c3">Pragmatik von <code>let</code> <i>(2)</i></h3>
<ul>
<li>Wenn Hilfsfunktionen nur reinen Hilfscharakter haben, d.h. nur im
Kontext der Hauptfunktion sinnvoll sind, kann es &#x2013; schon zur
Vermeidung von Namenskonflikten in der globalen Umgebung &#x2013;
zweckmäßig sein, Hilfsfunktionen lokal zu definieren.</li>
<li>Betrachten wir dazu eine weitere Variante von <code>sumprod</code> mit zwei
Hilfsfunktionen.</li>

</ul>

</section>
<section id="slide-orgddf8fbf">
<h3 id="orgddf8fbf"><code>sumprod</code> mit Hilfsfunktionen</h3>
<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">sumprod</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lon<span style="color: #909183;">]</span>
        <span style="color: #909183;">{</span><span style="color: #D0372D;">:pre</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? lon<span style="color: #907373;">)</span><span style="color: #709870;">]</span>
         <span style="color: #D0372D;">:post</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? <span style="color: #BA36A5;">%</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span><span style="color: #909183;">}</span>
        <span style="color: #909183;">(</span><span style="color: #006FE0;">list</span> <span style="color: #709870;">(</span>sum lon<span style="color: #709870;">)</span> <span style="color: #709870;">(</span>prod lon<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</div>
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">sum</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lon<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lon<span style="color: #709870;">)</span> 0
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>+ <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>sum <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lon<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">prod</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lon<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lon<span style="color: #709870;">)</span> 1
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>* <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>prod <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lon<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</section>
<section id="slide-org2c65473">
<h3 id="org2c65473"><code>sumprod</code> mit lokalen Hilfsfunktionen</h3>
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">sumprod</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lon<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">letfn</span>
            <span style="color: #709870;">[</span><span style="color: #907373;">(</span>sum <span style="color: #6276BA;">[</span>lon<span style="color: #6276BA;">]</span>
               <span style="color: #6276BA;">(</span><span style="color: #0000FF;">cond</span>
                <span style="color: #858580;">(</span><span style="color: #006FE0;">empty?</span> lon<span style="color: #858580;">)</span> 0
                <span style="color: #D0372D;">:else</span> <span style="color: #858580;">(</span>+ <span style="color: #80A880;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #80A880;">)</span> <span style="color: #80A880;">(</span>sum <span style="color: #887070;">(</span><span style="color: #006FE0;">rest</span> lon<span style="color: #887070;">)</span><span style="color: #80A880;">)</span><span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">)</span>
             <span style="color: #907373;">(</span>prod <span style="color: #6276BA;">[</span>lon<span style="color: #6276BA;">]</span>
               <span style="color: #6276BA;">(</span><span style="color: #0000FF;">cond</span>
                <span style="color: #858580;">(</span><span style="color: #006FE0;">empty?</span> lon<span style="color: #858580;">)</span> 1
                <span style="color: #D0372D;">:else</span> <span style="color: #858580;">(</span>* <span style="color: #80A880;">(</span><span style="color: #006FE0;">first</span> lon<span style="color: #80A880;">)</span> 
                         <span style="color: #80A880;">(</span>prod <span style="color: #887070;">(</span><span style="color: #006FE0;">rest</span> lon<span style="color: #887070;">)</span><span style="color: #80A880;">)</span><span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">list</span> <span style="color: #907373;">(</span>sum lon<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>prod lon<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

<p>
<b>Man beachte</b>, dass hier für die <code>rekursiven</code> lokalen Hilfsfunktionen
die Pseudofunktion <code>letfn</code> verwendet werden muss.
</p>
</section>
</section>
<section>
<section id="slide-orgb5f4e77">
<h2 id="orgb5f4e77">Funktionen höherer Ordnung (1)</h2>
<div class="outline-text-2" id="text-orgb5f4e77">
</div>
</section>
<section id="slide-org78071c8">
<h3 id="org78071c8">Entwurfsvorschriften bewirken ähnliche Funktionen</h3>
<p>
Zum Beispiel
</p>

<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">sum</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>x<span style="color: #909183;">]</span>
       <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
         <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> x<span style="color: #709870;">)</span> 0
         <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>+ <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> x<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>sum <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> x<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">prod</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>x<span style="color: #909183;">]</span> 
       <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
         <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> x<span style="color: #709870;">)</span> 1
         <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>* <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> x<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>prod <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> x<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

<p>
Worin unterscheiden sich die beiden Funktionen?
</p>

</section>
<section id="slide-orgb71d633">
<h3 id="orgb71d633">Entwurfsvorschriften bewirken ähnliche Funktionen</h3>
<p>
Hier:
</p>

<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">sum</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>x<span style="color: #909183;">]</span>
       <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
         <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> x<span style="color: #709870;">)</span> 0
<span style="color: #8D8D84;">;;                  </span><span style="color: #8D8D84; font-style: italic;">=</span>
         <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>+ <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> x<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>sum <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> x<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;;              </span><span style="color: #8D8D84; font-style: italic;">=</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">prod</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>x<span style="color: #909183;">]</span> 
       <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
         <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> x<span style="color: #709870;">)</span> 1
<span style="color: #8D8D84;">;;                  </span><span style="color: #8D8D84; font-style: italic;">=</span>
         <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>* <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> x<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>prod <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> x<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;;              </span><span style="color: #8D8D84; font-style: italic;">=</span></pre>
</pre>
</div>

</section>
<section id="slide-orgb43c2c7">
<h3 id="orgb43c2c7">Noch zwei ähnliche Funktionen</h3>
<p>
Beispiel: Aus einer ungeordneten Liste von Zahlen werden alle unterhalb/oberhalb eines
Schwellwerts heraus gefiltert:
</p>

<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span>  <span style="color: #BA36A5;">unterhalb/oberhalb</span> 
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lvz schwelle<span style="color: #909183;">]</span>
        <span style="color: #909183;">{</span><span style="color: #D0372D;">:pre</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? lvz<span style="color: #907373;">)</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">number?</span> schwelle<span style="color: #907373;">)</span><span style="color: #709870;">]</span>
         <span style="color: #D0372D;">:post</span> <span style="color: #709870;">[</span><span style="color: #907373;">(</span><span style="color: #006FE0;">every?</span> number? <span style="color: #BA36A5;">%</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span><span style="color: #909183;">}</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lvz <span style="color: #709870;">)</span> <span style="color: #709870;">()</span>
          <span style="color: #709870;">(</span><span style="color: #6434A3;">&lt;</span><span style="font-family: DejaVu Sans Mono,monospace,sans-serif; color: #000000; background-color: #FFFFFF;">/</span>&gt; <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lvz<span style="color: #907373;">)</span> schwelle<span style="color: #709870;">)</span>
<span style="color: #8D8D84;">;;         </span><span style="color: #8D8D84; font-style: italic;">===</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lvz<span style="color: #907373;">)</span>
                <span style="color: #907373;">(</span><span style="color: #6434A3;">unterhalb</span><span style="font-family: DejaVu Sans Mono,monospace,sans-serif; color: #000000; background-color: #FFFFFF;">/</span>oberhalb
                   <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lvz <span style="color: #6276BA;">)</span> schwelle<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span><span style="color: #6434A3;">unterhalb</span><span style="font-family: DejaVu Sans Mono,monospace,sans-serif; color: #000000; background-color: #FFFFFF;">/</span>oberhalb
                   <span style="color: #907373;">(</span><span style="color: #006FE0;">rest</span> lvz <span style="color: #907373;">)</span> schwelle<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</section>
<section id="slide-org7ff1ea9">
<h3 id="org7ff1ea9">Ähnliche Funktionen vermeiden</h3>
<ul>
<li>Die beiden Funktionen <code>unterhalb</code> und <code>oberhalb</code> unterscheiden sich
&#x2013; abgesehen von ihrem Namen &#x2013; nur in dem Vergleichsoperator.</li>
<li>Die Funktion <code>oberhalb</code> erzeugt man wahrscheinlich durch Kopieren und
Anpassen von <code>unterhalb</code>.</li>
<li>Kopieren von Code ist eine Todsünde wider die Pflegbarkeit von
Programmen.</li>
<li>Bessere Lösung:
Eine allgemein verwendbare Filterfunktion, der die Art der
Vergleichsoperation als Argument mitgegeben wird.</li>
<li>Wir brauchen eine Funktion, die eine Funktion als Argument
akzeptiert: <i>Funktion höherer Ordnung</i> (Typ 1).</li>

</ul>

</section>
<section id="slide-org75a2960">
<h3 id="org75a2960">Eine Filterfunktion</h3>
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">filtere: (number number -&gt; boolean) </span>
    <span style="color: #8D8D84;">;;            </span><span style="color: #8D8D84; font-style: italic;">(list-of number) number </span>
    <span style="color: #8D8D84;">;;          </span><span style="color: #8D8D84; font-style: italic;">-&gt;  (list-of number)</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">filtere</span> 
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>vglfkt lvz schwelle<span style="color: #909183;">]</span>
    <span style="color: #8D8D84;">;;     </span><span style="color: #8D8D84; font-style: italic;">======       </span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lvz<span style="color: #709870;">)</span> <span style="color: #709870;">()</span>

          <span style="color: #709870;">(</span>vglfkt <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lvz<span style="color: #907373;">)</span> schwelle<span style="color: #709870;">)</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lvz<span style="color: #907373;">)</span>
                <span style="color: #907373;">(</span>filtere vglfkt
                         <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lvz <span style="color: #6276BA;">)</span> schwelle<span style="color: #907373;">)</span><span style="color: #709870;">)</span>

          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>filtere vglfkt
                    <span style="color: #907373;">(</span><span style="color: #006FE0;">rest</span> lvz <span style="color: #907373;">)</span> schwelle<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

<ul>
<li>Um unterhalb zu realisieren, ruft man z.B. <code>filtere</code> so auf:<br />
<code>(filtere &lt; ’(3 4 5 6) 5) ;=&gt; (3 4)</code></li>
<li>Man beachte den Vertrag der Funktion (informelle Vertragsnotation)!</li>

</ul>

</section>
<section id="slide-orgc67f8b8">
<h3 id="orgc67f8b8">Funktionen sind Werte erster Ordnung</h3>
<ul>
<li><p>
Die Möglichkeit, Funktionen zu bauen, die andere Funktionen als
Argument erwarten, beruht auf einem ebenso einfachen wie
fundamentalen Prinzip:
</p>

<p>
<b>Funktionen sind Werte erster Ordnung</b>
</p></li>
<li><p>
Das bedeutet im Grunde, dass Funktionen überall dort, wo normale
Werte verwendet werden dürfen, ebenfalls benutzt werden können.
</p>

<p>
Sie dürfen daher als
</p>
<ul>
<li>Argumente von Funktionen benutzt,</li>
<li>als Resultate von Funktionen geliefert und</li>
<li>in Datenstrukturen verpackt<br /></li>

</ul>
<p>
werden.
</p></li>

</ul>

</section>
<section >

<ul>
<li>Das Prinzip eröffnet eine breite Palette an Programmiertechniken.</li>

<li>Hingegen schränken viele populäre Programmiersprachen die Verwendung
von Funktionen <b>willkürlich</b> ein!</li>

<li>Anmerkung: Funktionen mit Funktionen als Parameter gingen sogar
„schon” in Pascal.</li>

</ul>

</section>
<section id="slide-org10bb350">
<h3 id="org10bb350">Verallgemeinerung der Filterfunktion</h3>
<p>
Die Funktion <code>filter</code> wendet auf jedes Element der Zahlenliste das Prädikat <code>praed?</code>
an. In die Ergebnisliste werden die Elemente aufgenommen, für die das
Prädikat <code>true</code> liefert.
</p>

<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">filter: (number -&gt; boolean) (list-of number)  </span>
    <span style="color: #8D8D84;">;;         </span><span style="color: #8D8D84; font-style: italic;">-&gt;  (list-of number)</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">filter</span> 
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>praed? lvz<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lvz<span style="color: #709870;">)</span> <span style="color: #709870;">()</span> 

          <span style="color: #709870;">(</span>praed? <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lvz<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lvz<span style="color: #907373;">)</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">filter</span> praed? <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lvz<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>

          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">filter</span> praed? <span style="color: #907373;">(</span><span style="color: #006FE0;">rest</span> lvz <span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

    <span style="color: #707183;">(</span><span style="color: #006FE0;">deftest</span> <span style="color: #006699;">test-filter</span>
      <span style="color: #7388D6;">(</span><span style="color: #006FE0;">is</span> <span style="color: #909183;">(</span>= <span style="color: #709870;">(</span><span style="color: #006FE0;">filter</span> <span style="color: #907373;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #6276BA;">[</span>x<span style="color: #6276BA;">]</span> <span style="color: #6276BA;">(</span>&lt; x 5<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span> 
                     '<span style="color: #907373;">(</span>3 4 5 6 <span style="color: #907373;">)</span><span style="color: #709870;">)</span> '<span style="color: #709870;">(</span>3 4<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span>
      <span style="color: #7388D6;">(</span><span style="color: #006FE0;">is</span> <span style="color: #909183;">(</span>= <span style="color: #709870;">(</span><span style="color: #006FE0;">filter</span> odd? '<span style="color: #907373;">(</span>3 4 5 6 <span style="color: #907373;">)</span><span style="color: #709870;">)</span> '<span style="color: #709870;">(</span>3 5<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</section>
<section id="slide-org98fe1d7">
<h3 id="org98fe1d7">Eine Abstraktion für <code>sum</code> und <code>prod</code></h3>
<ul>
<li>Es kommt häufiger vor, dass man z.B. eine Liste von Zahlen zu einem
Wert zusammenfalten will.</li>
<li>Die verschiedenen Faltungsarten unterscheiden sich meist nur in dem
Basiswert (Ergebnis für die leere Liste) und der eigentlichen
Faltungsfunktion, z.B. Addition für <code>sum</code> und Multiplikation für
<code>prod</code>.</li>
<li><p>
Man beachte auch hier wieder den Vertrag der Funktion!
</p>

<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">falte: (number number -&gt; number) </span>
       <span style="color: #8D8D84;">;;        </span><span style="color: #8D8D84; font-style: italic;">number (list-of number)  -&gt; number</span>
       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">falte</span>
         <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>fltfkt basis lvz<span style="color: #909183;">]</span>
       <span style="color: #8D8D84;">;;     </span><span style="color: #8D8D84; font-style: italic;">====== =====</span>
           <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
            <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lvz<span style="color: #709870;">)</span> basis
       <span style="color: #8D8D84;">;;                </span><span style="color: #8D8D84; font-style: italic;">=====</span>
            <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>fltfkt <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lvz<span style="color: #907373;">)</span>
       <span style="color: #8D8D84;">;;          </span><span style="color: #8D8D84; font-style: italic;">======</span>
                          <span style="color: #907373;">(</span>falte fltfkt basis
                                 <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lvz<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgacad307">
<h2 id="orgacad307">Systematisierung der Ableitung von Funktionen höherer Ordnung</h2>
<div class="outline-text-2" id="text-orgacad307">
</div>
</section>
<section id="slide-org60bb2c7">
<h3 id="org60bb2c7">Zunächst zwei Beispiele</h3>
<ol>
<li>Quadrieren einer Liste von Zahlen</li>

</ol>

<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">quadrieren: (list-of number) -&gt; (list-of number)</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">quadrieren</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lvz<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lvz<span style="color: #709870;">)</span> <span style="color: #709870;">()</span>
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #907373;">(</span><span style="color: #6276BA;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #858580;">[</span>x<span style="color: #858580;">]</span> <span style="color: #858580;">(</span>* x x<span style="color: #858580;">)</span><span style="color: #6276BA;">)</span> <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> lvz<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span>
                      <span style="color: #907373;">(</span>quadrieren <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lvz<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</section>
<section >

<ol>
<li value="2">Extrahieren der Produktnamen aus einer Preisliste</li>

</ol>

<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84; font-style: italic;">; Ein Produkt ist ein Record</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">defrecord</span> <span style="color: #6434A3;">Produkt</span> <span style="color: #7388D6;">[</span>name preis<span style="color: #7388D6;">]</span><span style="color: #707183;">)</span>

    <span style="color: #8D8D84; font-style: italic;">; Eine Preisliste (pl) ist</span>
    <span style="color: #8D8D84; font-style: italic;">; () oder</span>
    <span style="color: #8D8D84; font-style: italic;">; (cons p pl), wobei p ein Produkt</span>
    <span style="color: #8D8D84; font-style: italic;">;   und pl eine Preisliste ist.</span>

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">produkt-namen: pl -&gt; (list-of symbol)</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">produkt-namen</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>pl<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> pl<span style="color: #709870;">)</span> <span style="color: #709870;">()</span>
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #907373;">(</span><span style="color: #D0372D;">:name</span> <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> pl<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span>
                 <span style="color: #907373;">(</span>produkt-namen <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> pl<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</section>
<section id="slide-org60c1456">
<h3 id="org60c1456">„Abstraktionsvorschrift“</h3>
<ul>
<li>Die beiden Funktionen <code>quadrieren</code> und <code>produkt-namen</code> unterscheiden
sich &#x2013; abgesehen von ihren Namen &#x2013; nur in der Funktion, die auf das
erste Listenelement angewendet wird.</li>

<li>Wann immer zwei (oder mehr) dieser Art ähnliche Funktionen auftreten,
gehe man folgendermaßen vor:

<ol>
<li>Markiere die Stellen in den Funktionen, wo sie sich unterscheiden.
Wenn sie sich nur in Werten (auch Funktionen sind Werte)
unterscheiden, ist eine Abstraktion möglich.</li>

<li>Führe für jedes Paar markierter Stellen einen neuen Namen ein.</li>

<li>Übernimm diesen Namen in die Liste der formalen Parameter der
Funktionen. Nach diesem Schritt müssen die beiden Funktionen außer
in ihrem Namen übereinstimmen.</li>

<li>Schließlich ersetzen wir die Funktionsnamen durch den Namen einer
neuen abstrakten Funktion.</li>

</ol></li>

<li>So entsteht aus <code>quadrieren</code> und <code>produkt-namen</code> formal die Funktion
<code>map</code> (siehe nächste Folie).</li>

</ul>

</section>
<section id="slide-org0c51956">
<h3 id="org0c51956">Die Funktion <code>map</code></h3>
<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">map: (listOf X) (X -&gt; Y) -&gt; (list-of Y)</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">map</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lst fun<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lst<span style="color: #709870;">)</span> <span style="color: #709870;">()</span>
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #907373;">(</span>fun <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> lst<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span>
                      <span style="color: #907373;">(</span><span style="color: #006FE0;">map</span> <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lst<span style="color: #6276BA;">)</span> fun<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</div>

<ul>
<li>Weitere Umbenennungen:

<ul>
<li>Aus den Parameternamen <code>pl</code> bzw. <code>lvz</code> wurde <code>lst</code>.</li>

</ul></li>

<li>Man beachte wieder den Vertrag der Funktion! X und Y sind sogenannte
Typparameter.</li>

<li>Als letzten Schritt des Abstraktionsprozesses definiert man die
Originalfunktionen mithilfe der neuen abstrahierten Funktion.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgdf2c542">
<h2 id="orgdf2c542">Noch einmal: Falten</h2>
<div class="outline-text-2" id="text-orgdf2c542">
</div>
</section>
<section id="slide-org92b21b9">
<h3 id="org92b21b9">Ein anderes Verständnis für <code>falte</code></h3>
<ul>
<li>Die Reduktion einer Liste zu einem Wert ist eine häufig vorkommende
Aufgabe.</li>

<li>Als Funktion höherer Ordnung gehört die Falte-Funktion zum
Standard-Repertoire funktionaler Programmiersysteme.</li>

<li>häufig verwendete Bezeichner: fold, reduce &#x2026;</li>

<li>Die Wirkung von <code>(falte + 0 '(11 17 5))</code><br />
kann man sich, wie folgt, veranschaulichen:
<ul>
<li><code>falte</code> ersetzt in der Argumentliste, die dem Ausdruck<br />
<code>(cons 11 (cons 17 (cons 5 ())))</code><br />
entspricht, jedes Auftreten von <code>cons</code> durch <code>+</code> und jedes Auftreten
von <code>()</code> durch 0:<br />
<code>(+ 11 (+ 17 (+ 5 0)))</code></li>
<li>Verallgemeinert: Jedes Auftreten von <code>cons</code> wird durch die
Faltungsfunktion (fltfkt) und jedes Auftreten von <code>()</code> durch den
Basiswert ersetzt.</li>

</ul></li>

</ul>

</section>
<section id="slide-org98cbf88">
<h3 id="org98cbf88">Weitere Anwendungen von <code>falte</code></h3>
<ul>
<li>Was liefern die Ausdrücke

<ol>
<li>(falte cons () '(a b c)) ?</li>

<li>(falte cons '(x y z) '(a b c)) ?</li>

</ol></li>

</ul>

</section>
<section id="slide-orgd3b4eec">
<h3 id="orgd3b4eec">Ein generisches <code>falte</code>: <code>reduce</code></h3>
<ul>
<li>Wir abstrahieren die Funktion <code>falte</code> bezüglich des Typs der
Listenelemente.</li>

<li>Aus dem Vertrag</li>

</ul>

<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">falte: (number number -&gt; number) number </span>
       <span style="color: #8D8D84;">;;        </span><span style="color: #8D8D84; font-style: italic;">(list-of number) -&gt; number</span></pre>
</pre>
</div>

</div>

<p>
wird:
</p>
<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">reduce: (X Y -&gt; Y) Y (list-of X) -&gt; Y</span></pre>
</pre>
</div>

</div>


</section>
<section id="slide-org1d4bfc0">
<h3 id="org1d4bfc0">Die Funktionsdefinition für <code>reduce</code></h3>
<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">reduce: (X Y -&gt; Y) Y (list-of X) -&gt; Y</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">reduce</span> 
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>combine base l<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> l<span style="color: #709870;">)</span> base
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>combine 
                  <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> l<span style="color: #907373;">)</span>
                  <span style="color: #907373;">(</span><span style="color: #006FE0;">reduce</span> combine base <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> l<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</div>

<ul>
<li>Der Parameter <code>base</code> steht für den Funktionswert im Fall der leeren
Liste.</li>

<li>Der Parameter <code>combine</code> ist die Funktion, die aus dem Zugriff auf das
erste Element der Liste und der Restliste den Funktionswert
ermittelt, falls die Liste <code>l</code> nicht leer ist.</li>

</ul>

</section>
<section id="slide-org4573b80">
<h3 id="org4573b80">Anwendungen von <code>reduce</code></h3>
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">sum: (list-of number)  -&gt;  number</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">sum</span> <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>list<span style="color: #909183;">]</span> <span style="color: #909183;">(</span><span style="color: #006FE0;">reduce</span> + 0 list<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">product: (list-of number)  -&gt;  number</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">product</span> <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>list<span style="color: #909183;">]</span> <span style="color: #909183;">(</span><span style="color: #006FE0;">reduce</span> * 1 list<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
      
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">erzeugt eine Liste aus all den Elemente von alox,</span>
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">fuer die praedikat? gilt </span>
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">filterr: (X  -&gt;  boolean) (list-of X) </span>
    <span style="color: #8D8D84;">;;           </span><span style="color: #8D8D84; font-style: italic;">-&gt; (list-of X)</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">filterr</span> 
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>praedikat? alox<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #709870;">[</span>cp <span style="color: #907373;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #6276BA;">[</span>x y<span style="color: #6276BA;">]</span> 
                   <span style="color: #6276BA;">(</span><span style="color: #0000FF;">cond</span> <span style="color: #858580;">(</span>praedikat? x<span style="color: #858580;">)</span> <span style="color: #858580;">(</span><span style="color: #006FE0;">cons</span> x y<span style="color: #858580;">)</span> 
                         <span style="color: #D0372D;">:else</span> y<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span>
          <span style="color: #709870;">(</span><span style="color: #006FE0;">reduce</span> cp <span style="color: #907373;">()</span> alox<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</section>
</section>
<section>
<section id="slide-orgb44b6e5">
<h2 id="orgb44b6e5">Funktionen höherer Ordnung (2)</h2>
<div class="outline-text-2" id="text-orgb44b6e5">
</div>
</section>
<section id="slide-orgc864dcf">
<h3 id="orgc864dcf">Funktionen mit Funktionen als Resultat</h3>
<ul>
<li><p>
Was liefert der Ausdruck <code>(inc 3)</code>, wenn die Funktion <code>inc</code> wie folgt
definiert ist?
</p>

<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">inc</span> 
         <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>n<span style="color: #909183;">]</span> <span style="color: #909183;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #709870;">[</span>z<span style="color: #709870;">]</span> <span style="color: #709870;">(</span>+ z n<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</div></li>

<li>Welches Resultat liefert eine Anwendung der Funktion <code>dot</code>?</li>

</ul>

<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">dot</span>
         <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>f g<span style="color: #909183;">]</span> <span style="color: #909183;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #709870;">[</span>x<span style="color: #709870;">]</span> <span style="color: #709870;">(</span>f <span style="color: #907373;">(</span>g x<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</div>

</section>
<section >

<ul>
<li><p>
Anwendung von <code>inc</code> und <code>dot</code>:
</p>

<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">inclist</span> 
         <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>x<span style="color: #909183;">]</span> <span style="color: #909183;">(</span><span style="color: #006FE0;">map</span> x <span style="color: #709870;">(</span><span style="color: #006FE0;">inc</span> 1<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">increv</span> 
         <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>x<span style="color: #909183;">]</span> <span style="color: #909183;">(</span><span style="color: #709870;">(</span>dot inclist reverse<span style="color: #709870;">)</span> x<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>  
        
       <span style="color: #707183;">(</span>increv '<span style="color: #7388D6;">(</span>3 13 23 33<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span> <span style="color: #8D8D84; font-style: italic;">;=&gt; (34 24 14 4)</span></pre>
</pre>
</div></li>

</ul>

</section>
<section id="slide-org8805d4f">
<h3 id="org8805d4f">Ableitung einer <code>map</code>-Alternative</h3>
<ul>
<li>Die Anwendung der „Abstraktionsvorschrift” aus dem Abschnitt
<i>Systematisierung der Ableitung von Funktionen höherer Ordnung</i> auf
die Funktionen <code>quadrieren</code> und <code>produkt-namen</code> führte zur Definition
der Funktion <code>map</code>.</li>

<li><code>map</code> ist eine Funktion höherer Ordnung vom Typ 1.</li>

<li><p>
Die Definition der urprünglichen Funktionen, z.B. <code>produkt-namen</code>,
geschieht dann unter Verwendung von <code>map</code>:
</p>

<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">produkt-namen</span>
           <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>pl<span style="color: #909183;">]</span> <span style="color: #909183;">(</span><span style="color: #006FE0;">map</span> pl produkt-name<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>        </pre>
</pre>
</div>

</div></li>

</ul>

</section>
<section >

<ul>
<li>Mit einer Funktion höherer Ordnung vom Typ 2 ist es nun aber auch
möglich, eine Funktion &#x2013; nennen wir sie <code>mapp</code> &#x2013; zu definieren, die
als Argument eine Funktion <code>f</code> erwartet und eine Funktion als
Resultat liefert, die <code>f</code> auf jedes Element einer Liste anwendet.</li>

</ul>


</section>
<section id="slide-orgb2e948e">
<h3 id="orgb2e948e">Modifikation der Abstraktionsvorschrift</h3>
<ul>
<li><p>
Setzen wir die Existenz von <code>mapp</code> voraus, können wir <code>produkt-namen</code>
wiederum so definieren:
</p>

<p>
<code>(def produkt-namen (mapp produkt-name))</code>
</p></li>

<li><p>
&#x2026;und <code>quadrieren</code>:
</p>

<p>
<code>(def quadrieren (mapp (fn [x] (* x x))))</code>
</p></li>

<li>Wir können <code>mapp</code> durch eine modifizierte Abstraktionsvorschrift
(vgl. Folie <b>Abstraktionsvorschrift</b>) gewinnen.</li>

</ul>

</section>
<section id="slide-orgcb851d9">
<h3 id="orgcb851d9">Modifizierte Abstraktionsvorschrift</h3>
<ul>
<li>Ausgangspunkt sind wieder zwei ähnliche Funktionen wie z.B.
<code>quadrieren</code> und <code>produkt-namen</code></li>
<li>Wir markieren wieder die Stellen in den Funktionen, wo sie sich
unterscheiden und</li>
<li>führen für jedes Paar markierter Stellen einen neuen Namen ein.</li>
<li><p>
Wenn diese Schritte formal so durchgeführt werden, sieht z.B. die
Funktion <code>produkt-namen</code> so aus:
</p>
<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">produkt-namen</span> <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>pl<span style="color: #909183;">]</span>
          <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
            <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> pl<span style="color: #709870;">)</span> <span style="color: #709870;">()</span>
            <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #907373;">(</span>fun <span style="color: #6276BA;">(</span><span style="color: #006FE0;">first</span> pl<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span>
                             <span style="color: #907373;">(</span>produkt-namen <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> pl<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</div></li>

<li>In dieser Definition tritt <code>fun</code> als freie Variable auf.</li>

</ul>

</section>
<section >

<ul>
<li>Um dies zu beseitigen, nehmen wir <code>fun</code> nicht &#x2013; wie in der ersten
Abstraktionsvorschrift &#x2013; in die Parameterliste auf, sondern
definieren <code>produkt-namen</code> lokal innerhalb einer Funktion <code>mapp</code> mit
<code>fun</code> als Parameter und <code>produkt-namen</code> als Resultat.</li>
<li><p>
<code>mapp</code> sieht dann so aus:
</p>

<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">mapp</span>
         <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>fun<span style="color: #909183;">]</span>
       <span style="color: #8D8D84;">;;     </span><span style="color: #8D8D84; font-style: italic;">===</span>
           <span style="color: #909183;">(</span><span style="color: #0000FF;">letfn</span> 
              <span style="color: #709870;">[</span><span style="color: #907373;">(</span>maplocal <span style="color: #6276BA;">[</span>lst<span style="color: #6276BA;">]</span>
       <span style="color: #8D8D84;">;;       </span><span style="color: #8D8D84; font-style: italic;">========</span>
                 <span style="color: #6276BA;">(</span><span style="color: #0000FF;">cond</span>
                  <span style="color: #858580;">(</span><span style="color: #006FE0;">empty?</span> list<span style="color: #858580;">)</span> <span style="color: #858580;">()</span>
                  <span style="color: #D0372D;">:else</span> <span style="color: #858580;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #80A880;">(</span>fun <span style="color: #887070;">(</span><span style="color: #006FE0;">first</span> lst<span style="color: #887070;">)</span><span style="color: #80A880;">)</span>
                              <span style="color: #80A880;">(</span>maplocal <span style="color: #887070;">(</span><span style="color: #006FE0;">rest</span> lst<span style="color: #887070;">)</span><span style="color: #80A880;">)</span><span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span>
       <span style="color: #8D8D84;">;;                      </span><span style="color: #8D8D84; font-style: italic;">========</span>
            maplocal<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
       <span style="color: #8D8D84;">;;   </span><span style="color: #8D8D84; font-style: italic;">========</span></pre>
</pre>
</div></li>

</ul>

</section>
<section >

<ul>
<li>Der in der abstrahierten Funktion nun bedeutungslos gewordene
Bezeichner <code>produkt-namen</code> ist hier durch den generischen Bezeichner
<code>maplocal</code> ersetzt worden.</li>

<li><p>
Die Anwendung 
</p>

<p>
<code>(mapp (fn [x] (* x x)))</code> 
</p>

<p>
liefert nun eine Funktion,
die, angewendet auf eine Liste (von Zahlen), jedes Element quadriert.
</p></li>

<li><b>Frage: Wie lautet der Vertrag von <code>mapp</code>?</b> (Antwort als Aufgabe)</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgac93981">
<h2 id="orgac93981">Rekursive und iterative Prozesse</h2>
<div class="outline-text-2" id="text-orgac93981">
</div>
</section>
<section id="slide-org1e27b00">
<h3 id="org1e27b00">Fakultät rekursiv</h3>
<p>
Ausgehend von der mathematischen 
efinition:
</p>

<p>
\(n! = n \cdot (n-1) \cdot (n-2) \cdot\cdot\cdot 2 \cdot 1 =
        n\cdot (n-1)!\)
</p>

<p>
kann folgende rekursive Funktionsdefinition gegeben werden:
</p>

<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">factorial</span>
       <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>n<span style="color: #909183;">]</span>
          <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
             <span style="color: #709870;">(</span>= n 1<span style="color: #709870;">)</span> 1
             <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>* n <span style="color: #907373;">(</span>factorial <span style="color: #6276BA;">(</span>- n 1<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</div>

<p>
Die Anwendung <code>(factorial 6)</code> führt zu einem rekursiven
Abarbeitungsprozess, siehe nächste Folie.
</p>

</section>
<section id="slide-org58cdbe3">
<h3 id="org58cdbe3">rekursive Abarbeitung der Fakultät</h3>

<div class="figure">
<p><img src="./Abbildungen/faktreku.png" alt="faktreku.png" width="600px" />
</p>
</div>

<p>
 
</p>

</section>
<section id="slide-org5eba780">
<h3 id="org5eba780">Fakultät iterativ</h3>
<p>
\(n! = 1  \cdot 2 \cdot\cdot\cdot (n-1) \cdot n\)
</p>

<p>
Berechnung der Fakultät im „Vorwärtsgang” mit zwei Hilfsvariablen:
</p>

<p>
<code>product</code> \(\leftarrow\) <code>product * counter</code>
</p>

<p>
<code>counter</code> \(\leftarrow\) <code>counter + 1</code>
</p>

<p>
<code>product</code> ist gleich \(n!\), wenn <code>counter</code> größer als \(n\) ist.
</p>

<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">factorial</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>n<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span>fact-iter 1 1 n<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">fact-iter</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>product counter max-counter<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
          <span style="color: #709870;">(</span>&gt; counter max-counter<span style="color: #709870;">)</span> product
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>fact-iter <span style="color: #907373;">(</span>* product counter<span style="color: #907373;">)</span> 
                           <span style="color: #907373;">(</span>+ counter 1<span style="color: #907373;">)</span>
                           max-counter<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</section>
<section id="slide-orgfd50771">
<h3 id="orgfd50771">iterative Abarbeitung der Fakultät</h3>

<div class="figure">
<p><img src="./Abbildungen/faktiter.png" alt="faktiter.png" width="500px" />
</p>
</div>


</section>
<section id="slide-orge7230d8">
<h3 id="orge7230d8">Fakultät iterativ mit lokaler Hilfsfunktion</h3>
<ul>
<li>Die Funktion <code>fact-iter</code> hat einen reinen Hilfscharakter, d.h. sollte
nur von <code>factorial</code> aufgerufen werden.</li>

<li><p>
Konsequenz: Funktion <code>fact-iter</code> lokal definieren:
</p>

<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">factorial</span>
         <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>n<span style="color: #909183;">]</span>
           <span style="color: #909183;">(</span><span style="color: #0000FF;">letfn</span> 
               <span style="color: #709870;">[</span><span style="color: #907373;">(</span>fact-iter <span style="color: #6276BA;">[</span>product counter<span style="color: #6276BA;">]</span>
                  <span style="color: #6276BA;">(</span><span style="color: #0000FF;">cond</span> 
                   <span style="color: #858580;">(</span>&gt; counter n<span style="color: #858580;">)</span> product
                   <span style="color: #D0372D;">:else</span> <span style="color: #858580;">(</span>fact-iter <span style="color: #80A880;">(</span>* product counter<span style="color: #80A880;">)</span> 
                                    <span style="color: #80A880;">(</span>+ counter 1<span style="color: #80A880;">)</span><span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span>
             <span style="color: #709870;">(</span>fact-iter 1 1<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div></li>

<li>Beachte: Das dritte Argument für <code>fact-iter</code> ist überflüssig
geworden.</li>

</ul>

</section>
<section id="slide-org0f2f4b8">
<h3 id="org0f2f4b8">loop/recur in Clojure</h3>
<ul>
<li>Clojure erlaubt wegen der Java-Aufrufkonventionen keine
Endrekursionsoptimierung.</li>

<li>Ersatzweise existiert die loop/recur-Konstruktion:</li>

</ul>

<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">factorial</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>n<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">loop</span> <span style="color: #709870;">[</span>product 1 counter 1<span style="color: #709870;">]</span> 
          <span style="color: #709870;">(</span><span style="color: #0000FF;">cond</span> 
           <span style="color: #907373;">(</span>&gt; counter n<span style="color: #907373;">)</span> product
           <span style="color: #D0372D;">:else</span> <span style="color: #907373;">(</span><span style="color: #0000FF;">recur</span> <span style="color: #6276BA;">(</span>* product counter<span style="color: #6276BA;">)</span> 
                        <span style="color: #6276BA;">(</span>+ counter 1<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>    
      </pre>
</pre>
</div>

</section>
<section id="slide-org8418448">
<h3 id="org8418448">Akkumulierende Parameter</h3>
<ul>
<li>Ein <i>rekursiver Prozess</i> ist durch eine Folge von verzögerten
Operationen gekennzeichnet.</li>

<li>Der Speicherbedarf für das Merken von noch nicht ausgeführten
Operationen wächst linear mit \(n\).</li>

<li>Die iterative Abarbeitung erfordert hingegen nur konstanten
Speicherbedarf für die Werte von <code>product</code>, <code>counter</code>
<code>und max-counter</code>.</li>

<li><code>product</code> bezeichnet man als <i>akkumulierenden Parameter</i>.</li>

<li>Akkumulierende Parameter ermöglichen oft die iterative Abarbeitung
rekursiver Funktionen.</li>

<li>Akkumulierende Parameter führen oft zu effizienteren Funktionen.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orga2e2021">
<h2 id="orga2e2021">Akkumulierende Parameter</h2>
<div class="outline-text-2" id="text-orga2e2021">
</div>
</section>
<section id="slide-org7f411c1">
<h3 id="org7f411c1">Invertieren einer Liste</h3>
<div class="large">
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">kehrt die Reihenfolge der Symbole einer Liste um</span>
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">rev-list: (list-of symbol) -&gt; (list-of symbol)</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">rev-list</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lst<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lst<span style="color: #709870;">)</span> <span style="color: #709870;">()</span>
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span>putatend <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lst<span style="color: #907373;">)</span> 
                          <span style="color: #907373;">(</span>rev-lst <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lst<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">stellt das Symbol an das Ende der Lste</span>
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">putatend: symbol (list-of symbol) -&gt; (list-of symbol)</span>
    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">putatend</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>symbl lst<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span> 
          <span style="color: #709870;">(</span><span style="color: #006FE0;">empty?</span> lst<span style="color: #709870;">)</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">cons</span> symbl <span style="color: #907373;">()</span> <span style="color: #709870;">)</span>
          <span style="color: #D0372D;">:else</span> <span style="color: #709870;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #907373;">(</span><span style="color: #006FE0;">first</span> lst<span style="color: #907373;">)</span> 
                      <span style="color: #907373;">(</span>putatend symbl <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> lst<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</div>

</section>
<section id="slide-org1273b9b">
<h3 id="org1273b9b">Effizienzbetrachtung:</h3>
<ul>
<li>Vorbemerkung: Beide Funktionen entstehen durch Anwendung der
bekannten Entwurfsvorschriften.</li>

<li><code>putatend</code> wird \(n\) -mal rekursiv aufgerufen, wenn \(n\) die
Mächtigkeit der Liste ist, d.h. <code>cons</code> wird \(n\) -mal ausgeführt.</li>

<li><code>rev-list</code> ruft sich selbst ebenfalls \(n\) -mal auf.</li>

<li>Jeder Aufruf von <code>rev-list</code> ruft einen Aufruf von <code>putatend</code> hervor.</li>

<li>Für diese Aufrufe von <code>putatend</code> ist die Länge des zweiten
Arguments \(n-1, n-2\ldots 1, 0\).</li>

<li>Die Anzahl der <code>cons</code>-Aufrufe von <code>putatend</code> beträgt:
\[0 + 1 + \cdots + n-1 = \frac{n(n-1)}{2}\]</li>

<li>Die Funktion <code>rev-list</code> wächst quadratisch:
\(O(\texttt{rev-list})=n^2\).</li>

<li>Das Invertieren einer Liste sollte aber nur linearen Aufwand
erfordern.</li>

<li>Lösung: Hilfsfunktion mit akkumulierendem Parameter</li>

</ul>

</section>
<section id="slide-org07fd71b">
<h3 id="org07fd71b">Invertieren einer Liste</h3>
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">kehrt die Reihenfolge der Symbole einer Liste um</span>
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">rev-list: (list-of symbol) -&gt; (list-of symbol)</span>
     <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">rev-list</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lst<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">loop</span> <span style="color: #709870;">[</span>list-x lst list-y <span style="color: #907373;">()</span><span style="color: #709870;">]</span>
                <span style="color: #709870;">(</span><span style="color: #0000FF;">cond</span> 
                  <span style="color: #907373;">(</span><span style="color: #006FE0;">empty?</span> list-x<span style="color: #907373;">)</span> list-y
                  <span style="color: #D0372D;">:else</span> <span style="color: #907373;">(</span><span style="color: #0000FF;">recur</span> <span style="color: #6276BA;">(</span><span style="color: #006FE0;">rest</span> list-x<span style="color: #6276BA;">)</span> 
                               <span style="color: #6276BA;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #858580;">(</span><span style="color: #006FE0;">first</span> list-x<span style="color: #858580;">)</span> 
                                     list-y<span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

<ul>
<li>Die Anzahl der <code>cons</code>-Aufrufe in <code>rev</code> wächst linear mit der Länge
der Liste.</li>

</ul>

</section>
<section id="slide-orga3685eb">
<h3 id="orga3685eb">Einsatz von akkumulierenden Parametern</h3>
<ul>
<li>Im Zusammenhang mit akkumulierenden Parametern sind zwei Fragen
interessant:

<ol>
<li>Woran erkennt man, dass eine Funktion von akkumulierenden
Parametern profitieren kann?</li>

<li>Was muss ggf. in einem akkumulierenden Parameter eigentlich
akkumuliert werden?</li>

</ol></li>

<li>Schwierigkeit beim Entwurf einer solchen Hilfsfunktion: Die bekannten
Entwurfsvorschriften sind nicht ohne weiteres anwendbar.</li>

</ul>

</section>
<section id="slide-org41f14fe">
<h3 id="org41f14fe">Vorgehensweise beim Entwurf</h3>
<ul>
<li>Da war zunächst die Frage, ob eine Funktion mit akkumulierendem
Parameter zweckmäßig ist.</li>

<li>Frage ist im Allgemeinen nicht leicht zu beantworten.</li>

<li>Indiz: Die Anwendung der bekannten Entwurfsvorschriften liefert eine
Funktion, die die Liste rekursiv abarbeitet unter Verwendung einer
Hilfsfunktion, die die Liste ebenfalls rekursiv abarbeitet.</li>

<li>Hier ist eine Effizienzbetrachtung angebracht.</li>

<li>Vergleiche die Definition von <code>rev-list</code> mit Hilfsfunktion
<code>putatend</code>.</li>

<li>Der Entwurf einer Hilfsfunktion mit akkumulierendem Parameter
vollzieht sich dann in zwei Schritten:

<ol>
<li>Man schreibt zunächst eine Funktionsschablone für die Funktion
samt lokaler Hilfsfunktion mit akkumulierendem Parameter auf.
Siehe nächste Folie!</li>

<li>Man beschreibt präzise die Aufgabe des akkumulierenden Parameters
durch eine sogenannte <i>Akkumulatorinvariante</i>. Siehe übernächste
Folie!</li>

</ol></li>

</ul>

</section>
<section id="slide-org27228e8">
<h3 id="org27228e8">Funktionsschablone für <code>rev-list</code> mit <code>rev</code></h3>
<div class="org-src-container">

<pre  class="src src-clojure">    <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">rev-list</span>
      <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lst<span style="color: #909183;">]</span>
        <span style="color: #909183;">(</span><span style="color: #0000FF;">letfn</span>
          <span style="color: #709870;">(</span>rev <span style="color: #907373;">[</span><span style="color: #808080;">listX</span> akku<span style="color: #907373;">]</span>
           <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Akkumulator ...</span>
            <span style="color: #907373;">(</span><span style="color: #0000FF;">cond</span> 
              <span style="color: #6276BA;">(</span><span style="color: #006FE0;">empty?</span> <span style="color: #808080;">listX</span><span style="color: #6276BA;">)</span> ... akku ...
              <span style="color: #D0372D;">:else</span> ... <span style="color: #6276BA;">(</span>rev <span style="color: #858580;">(</span><span style="color: #006FE0;">rest</span> <span style="color: #808080;">listX</span><span style="color: #858580;">)</span> 
                             ... <span style="color: #858580;">(</span><span style="color: #006FE0;">first</span> <span style="color: #808080;">listX</span><span style="color: #858580;">)</span> ... akku<span style="color: #6276BA;">)</span>
    <span style="color: #8D8D84;">;;                       </span><span style="color: #8D8D84; font-style: italic;">==========================     </span>
                            <span style="color: #907373;">)</span><span style="color: #709870;">)</span>
          <span style="color: #709870;">(</span>rev lst ...<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span></pre>
</pre>
</div>

<ul>
<li>Das Argument für den akkumulierenden Parameter im rekursiven Aufruf
der lokalen Hilfsfunktion <code>rev</code> ist hier unterstrichen.</li>

<li>Es muss so bestimmt werden, dass die noch zu definierende
Akkumulatorinvariante gültig bleibt.</li>

</ul>

</section>
<section id="slide-org2b30570">
<h3 id="org2b30570">Akkumulatorinvariante für <code>rev</code></h3>
<ul>
<li>Eine Akkumulatorinvariante ist eine Aussage über das Argument der
Hauptfunktion (hier: <code>lst</code>), das entsprechende Argument der
Hilfsfunktion (hier: <code>listX</code>) und den Akkumulator, die vor und nach
jedem rekursiven Aufruf der Funktion gilt.</li>

<li>Für den letzten Aufruf von <code>rev</code> gilt: \(listX = 
           ()\). Wenn wir voraussetzen, dass <code>akku</code> dann das invertierte
<code>lst</code> enthält, können wir die Schablone für den Fall, dass das
Argument <code>listX</code> von <code>rev</code> <code>()</code> ist, so ergänzen:
<code>(empty? listX) akku</code>.</li>

<li>Für den ersten Aufruf von <code>rev</code> gilt: \(listX = 
           lst\). Da beim Invertierungsprozess keine Listenelemente
hinzukommen, kann die Schablone hier so ergänzt werden:
<code>(rev lst () )</code>.</li>

<li>Da bei jedem rekursiven Aufruf von <code>rev</code> vorne ein Element von
<code>listX</code> wegenommen wird, muss <code>(first listX)</code> an den Anfang der Liste
<code>akku</code> gestellt werden. Damit ergibt sich für den unterstrichenen Teil der
Schablone: <code>(cons (first listX) akku))</code>.</li>

</ul>

</section>
<section >

<ul>
<li>Akkumulatorinvariante: <code>akku</code> ist eine Liste mit denjenigen Elementen
von <code>lst</code> in umgekehrter Reihenfolge, die denen von <code>listX</code>
vorangehen.</li>

<li><p>
Damit ergibt sich für <code>rev-list</code> mit <code>rev</code>:
</p>

<div class="small">
<div class="org-src-container">

<pre  class="src src-clojure">       <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">rev-list</span>
         <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>lst<span style="color: #909183;">]</span>
           <span style="color: #909183;">(</span><span style="color: #0000FF;">letfn</span>
             <span style="color: #709870;">[</span><span style="color: #907373;">(</span>rev <span style="color: #6276BA;">[</span><span style="color: #808080;">listX</span> akku<span style="color: #6276BA;">]</span>
               <span style="color: #6276BA;">(</span><span style="color: #0000FF;">cond</span> 
                 <span style="color: #858580;">(</span><span style="color: #006FE0;">empty?</span> <span style="color: #808080;">listX</span><span style="color: #858580;">)</span> akku 
                 <span style="color: #D0372D;">:else</span>  <span style="color: #858580;">(</span>rev <span style="color: #80A880;">(</span><span style="color: #006FE0;">rest</span> <span style="color: #808080;">listX</span><span style="color: #80A880;">)</span> 
                             <span style="color: #80A880;">(</span><span style="color: #006FE0;">cons</span> <span style="color: #887070;">(</span><span style="color: #006FE0;">first</span> <span style="color: #808080;">listX</span><span style="color: #887070;">)</span> akku<span style="color: #80A880;">)</span><span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span>
             <span style="color: #709870;">(</span>rev lst <span style="color: #907373;">()</span> <span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span></pre>
</pre>
</div>

</div></li>

</ul>

<p>
Da die Funktion <code>rev</code> end-rekursiv ist, sollte in <b>Clojure</b> das
<code>loop/recur</code>-Konstrukt &#x2013; wie oben gezeigt &#x2013; verwendet werden.
</p>

</section>
</section>
<section>
<section id="slide-org2a0042f">
<h2 id="org2a0042f">Zusammenfassung</h2>
<ul>
<li>Funktionen sind Werte erster Ordnung.</li>

<li>Funktionen höherer Ordnung erfordern weder syntaktische noch
semantische Erweiterungen der Programmiersprache.</li>

<li>Funktionen höherer Ordnung stellen ein mächtiges Abstraktionsmittel
bereit: „iterative“ Abstraktion.</li>

<li>Die „klassischen” Funktionen höherer Ordnung:

<ul>
<li>reduce</li>

<li>filter</li>

<li>map</li>

</ul></li>

<li>Lokale Definitionen und akkumulierende Parameter sind häufig benutzte
funktionale Ausdrucksmittel bzw. Programmiertechniken.</li>

</ul>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,
margin: 0.05,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: './reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
,dependencies: [ { src: 'plugin/menu/menu.js', async: true }, { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true } ]});
</script>
</body>
</html>
