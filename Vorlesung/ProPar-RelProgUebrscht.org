# +SETUPFILE: /Users/johannes/Documents/myOrg/org-html-themes/setup/theme-bigblow.setup
#+SETUPFILE: ./theme-bigblow-local.setup
#+TITLE: Relationale Programmierung: Übersicht
#+SUBTITLE: Programmierparadigmen
#+AUTHOR: Johannes Brauer
#+OPTIONS:   H:4
#+OPTIONS: num:nil d:nil
#+OPTIONS: toc:nil
#+OPTIONS: reveal_single_file:nil
#+Language:  de
#+STARTUP: latexpreview
#+STARTUP: inlineimages
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="mycss/mystyle.css" />
# +REVEAL_ROOT: http://cdn.jsdeZustandsbehaftete Programmierung in funktionalen Sprachen]]livr.net/reveal.js/3.0.0/
#+REVEAL_THEME: simple
#+REVEAL_TRANS: slide
#+REVEAL_HLEVEL: 1
#+REVEAL_INIT_SCRIPT: dependencies: [ { src: 'plugin/menu/menu.js', async: true },
#+REVEAL_INIT_SCRIPT:                 { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true } ]
#+REVEAL_MARGIN: 0.05
#+REVEAL_EXTRA_CSS: ./mycss/myrevealstyle.css
#+OPTIONS: reveal_control:t
* Von der funktionalen zur relationalen Programmierung
** Übliche Klassifikation der Programmierparadigmen (vgl. auch [[file:ProPar-Einstieg.org::*Was%20ist%20ein%20Programmierparadigma?][5. Semester]]) 
+--------------------------------+------------------------------+
|   Imperative Programmierung    | Deklarative Programmmierung  |
+--------------+-----------------+---------------+--------------+
|Prozedurrale  |Objektorientierte|Funktionale    |Logische      |
|Programmierung|Programmierung   |Programmierung |Programmierung|
+--------------+-----------------+---------------+--------------+

** Modifizierte Klassifikation
+--------------------------------+-------------------------------------+
|   Imperative Programmierung    | Deklarative Programmmierung         |
+--------------+-----------------+---------------+---------------------+
|Prozedurrale  |Objektorientierte|Funktionale    |<b>Relationale</b>   |
|Programmierung|Programmierung   |Programmierung |<b>Programmierung</b>|
+--------------+-----------------+---------------+---------------------+

+ Es gibt eine akademische Diskussion über den Unterschied zwischen
  logischer und relationaler Programmierung.
+ Gelegentlich wird die logische Programmierung (insbesondere im
  Kontext der Programmiersprache /Prolog/) als Erweiterung der
  relationalen Programmierung angesehen (vgl. dazu Kapitel über
  logische Programmierung).
+ Hier wird der Begriff in Abgrenzung zur funktionalen Programmierung
  als eine Spielart der deklarativen Programmierung angesehen:
#+BEGIN_QUOTE
*Spezifiziere das
Problem und das System ermittelt das Ergebnis.*
#+END_QUOTE

* Überblick

#+ATTR_REVEAL: :frag roll-in
#+begin_uebereinander
#+attr_html: :width 750px
[[file:./Abbildungen/FunktionenRelationenConstraint.png]]
#+end_uebereinander
#+ATTR_REVEAL: :frag fade-in
#+begin_uebereinander 
#+attr_html: :width 750px
[[file:./Abbildungen/FunktionenRelationenConstraint1.png]]
#+end_uebereinander
#+ATTR_REVEAL: :frag fade-in
#+begin_uebereinander 
#+attr_html: :width 750px
[[file:./Abbildungen/FunktionenRelationenConstraint2.png]]
#+end_uebereinander
#+ATTR_REVEAL: :frag fade-in
#+begin_uebereinander 
#+attr_html: :width 750px
[[file:./Abbildungen/FunktionenRelationenConstraint3.png]]
#+end_uebereinander
#+ATTR_REVEAL: :frag fade-in
#+begin_uebereinander 
#+attr_html: :width 750px
[[file:./Abbildungen/FunktionenRelationenConstraint4.png]]
#+end_uebereinander
#+ATTR_REVEAL: :frag fade-in
#+begin_uebereinander 
#+attr_html: :width 750px
[[file:./Abbildungen/FunktionenRelationenConstraint5.png]]
#+end_uebereinander
#+ATTR_REVEAL: :frag fade-in
#+begin_uebereinander 
#+attr_html: :width 750px
[[file:./Abbildungen/FunktionenRelationenConstraint6.png]]
#+end_uebereinander
#+ATTR_REVEAL: :frag fade-in
#+begin_uebereinander 
#+attr_html: :width 750px
[[file:./Abbildungen/FunktionenRelationenConstraint7.png]]
#+end_uebereinander
#+ATTR_REVEAL: :frag fade-in
#+begin_uebereinander 
#+attr_html: :width 750px
[[file:./Abbildungen/FunktionenRelationenConstraint8.png]]
#+end_uebereinander

* Beispiel: Natürliche Zahlen
#  [[https://cliplab.org/~vocal/public_info/seminar_notes/node36.html][Constructing Recursive Data Structures]]: dortiges natural-Prädikat
#  (Peano) eventuell als Übergang von FP nach LP verwenden.
+ Natürliche Zahlen können mithilfe der Peano-Axiome definiert werden:
  + $z$ ist eine natürliche Zahl (steht für die 0, zero).
  + $s(N)$ ist eine natürliche Zahl, wenn $N$ eine natürliche Zahl ist.
** Funktionale Implementierung
(vgl. auch [[file:ProPar-FuProNatRekrsn.org::*Rekursive%20Definition%20der%20nat%C3%BCrlichen%20Zahlen][Rekursive Definition der natürlichen Zahlen]]!)
#+BEGIN_SRC clojure
;; z ist eine natürliche Zahl (steht für die 0, zero).
(def z 'z)

;; + (s N) ist eine natürliche Zahl, wenn N eine natürliche Zahl ist.
;; s: Nat -> Nat
(def s
  (fn [n] (list 's n)))

(deftest test-s
  (is (= (s z) (s z)))
  (is (=  (s (s z)) (s (s z)))))
#+END_SRC
*** Axiome für die Vorgängeroperation und die Addition
-  Wir definieren zwei weitere Operationen zur
   -  Ermittlung des Vorgängers einer natürlichen Zahl: $pred$
   -  Addition von zwei natürlichen Zahlen: $plus$
-  Die Definitionen nehmen wir dadurch vor, dass wir die
   Wechselwirkungen der neuen Operationen mit den Basisoperationen $z$
   und $s(n)$ zunächst durch Gleichungen beschreiben.
   -  Für $pred$ gelte (mit $n$ als natürlicher Zahl):
      $$\begin{aligned}
                      pred(s(n)) & =  n  & \\
                      pred(z) & \  \mathrm{ undefiniert}
                  \end{aligned}$$
   -  Für $plus$ gelte (mit $n$ als natürlicher Zahl):
      $$\begin{aligned}
                       plus(z, n) & =  n  \\
                       plus(s(n), m) & = s(plus(n, m))  
                   \end{aligned}$$
*** Implementierung von =plus=
#+BEGIN_SRC clojure
;; berechnet die Summe ihrer Argumente
;; plus: Nat Nat -> Nat
(def plus
  (fn [n m]
    (cond 
      (= n z) m
      :else (s (plus (pred n) m)))))

(deftest test-plus
  (is (= (plus z (s z))  (s z)))
  (is (= (plus (s z) (s z))
         (s (s z))))
  (is (= (plus (s z)
               (plus (s z) (s z)))
         (s (s (s z))))))
#+END_SRC

*** Implementierung von =pred=
#+BEGIN_SRC clojure
;; liefert den Term des Vorgaengers ihres Arguments
;; pred: Nat -> Nat
(def pred
  (fn [n]
    (cond
      (= n z) (throw  (Exception. "z hat keinen Vorgaenger"))
      :else
      (first (rest n)))))

(deftest test-pred
  (is (=  (pred (s z)) z))
  (is (=  (pred (s (s z))) (s z)))
  (is (thrown? Exception (pred z))))
#+END_SRC
** Logische Implementierung
Natürliche Zahlen werden durch das folgende Prädikat, bestehend aus
zwei Termen, definiert:

#+begin_small
#+BEGIN_SRC prolog
natural(z).
natural(s(N)):- natural(N).
#+END_SRC
#+end_small

+ Die Prüfung auf „null” und „größer als null” geschieht hier
  automatisch durch Mustervergleich:
  + =z= passt nicht zu =s(z)= und
  + umgekehrt. 
+ Eine =pred=-Operation ist hier nicht erforderlich, weil, wenn das
  Argument des Prädikats auf =s(N)= passt, dann ist =N= per Definition
  durch die Peano-Asiome der Vorgänger von =s(N)=.

*** Anwendungen des Prädikats =natural=:
#+BEGIN_SRC prolog
Welcome to SWI-Prolog (threaded, 64 bits, version 7.4.2)
...
?- cd('/Users/Shared/Dropbox/Programmierparadigmen/prolog').
true.
?- consult('natural.pl').
true.

?- natural(z).
true.
?- natural(y).
false.
?- natural(s(s(s(z)))).
true.
?- natural(X).
X = z ?;
X = s(z) ?;
X = s(s(z)) ?;
X = s(s(s(z))) ?
#+END_SRC

*** Die Addition
Die Axiome für =plus=
      $$\begin{aligned}
                       plus(z, n) & =  n  \\
                       plus(s(n), m) & = s(plus(n, m))  
                   \end{aligned}$$
werden wie folgt in logische Ausdrücke übertragen:
#+begin_small
#+BEGIN_SRC prolog
plus(z, N, N):- natural(N).
plus(s(N), M, s(X)):- plus(N, M, X).
#+END_SRC
#+end_small
+ Mit der ersten Klausel wird die erste Gleichung realisiert, wobei
  der Aufruf von =natural(N)= dafür sorgt, dass das zweite und dritte
  Argument von =plus= natürliche Zahlen sind.
+ Die zweite kann als logischer Ausdruck wie folgt gelesen
  werden:\\
  Wenn =X= die Summe von =N= und =M= ist, dann ist die Summe des
  Nachfolgers von =N= (=s(N)=) und =M= der Nachfolger von =X= (=s(X)=).

*** Anwendungen des Prädikats =plus=:
#+BEGIN_SRC prolog
% für die Addtion:
?- plus(s(s(z)), s(z), R).
R = s(s(s(z))).
% für die Subtraktion:
?- plus(s(s(s(z))), T, s(s(s(s(s(z)))))).
T = s(s(z)).
?- plus(s(s(s(s(s(z))))), T, s(s(s(z)))).
false
% um eine Zahl zu zerlegen:
?- plus(X, Y, s(s(z))).
X = z,
Y = s(s(z)) ;
X = Y, Y = s(z) ;
X = s(s(z)),
Y = z ;
false.
#+END_SRC

* Erste Erkenntnisse
+ Logische Programme sind kürzer als funktionale.
+ Relationen sind vielseitiger verwendbar als Funktionen.
