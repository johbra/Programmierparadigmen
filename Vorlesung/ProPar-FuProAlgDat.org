# +SETUPFILE: /Users/johannes/Documents/myOrg/org-html-themes/setup/theme-bigblow.setup
#+SETUPFILE: ./theme-bigblow-local.setup
#+TITLE: Funktionale Programmierung -- Algebraische Datentypen
#+SUBTITLE: Programmierparadigmen
#+AUTHOR: Johannes Brauer
#+OPTIONS:   H:4
#+OPTIONS: num:nil d:nil
#+OPTIONS: toc:nil
#+OPTIONS: reveal_single_file:nil
#+Language:  de
#+STARTUP: latexpreview
#+STARTUP: inlineimages
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="mycss/mystyle.css" />
# +REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_THEME: simple
#+REVEAL_TRANS: slide
#+REVEAL_HLEVEL: 1
#+REVEAL_INIT_SCRIPT: dependencies: [ { src: 'plugin/menu/menu.js', async: true },
#+REVEAL_INIT_SCRIPT:                 { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true } ]
#+REVEAL_MARGIN: 0.05
#+REVEAL_EXTRA_CSS: ./mycss/myrevealstyle.css
#+OPTIONS: reveal_control:t

# um Folien mit reveal.js erzeugen zu können:ml
# M-x load-library und dann ox-reveal

* Datenstrukturen 

** Datenstrukturen als Datenabstraktion

-  Grundgedanke: Einzelne Dinge werden zu einem neuen Ganzen.

   -  Aus 5000 Einzelteilen entsteht ein Auto.

   -  Aus zwei Keksen und Schokocreme entsteht ein Waffelkeks.

   -  Aus zwei Koordinaten entsteht ein Punkt.

   -  Aus einer Menge von Merkmalen entsteht eine Objektstruktur.

-  ein Beispiel:

#+BEGIN_EXAMPLE
    ; Ein Punkt besteht aus
    ; - einer Zahl für die X-,
    ; - einer Zahl für die Y-Koordinate
    ; ->punkt : number number -> punkt
    ; :x :     punkt -> number
    ; :y :    punkt -> number
#+END_EXAMPLE

** Record-Definition in Clojure
#+BEGIN_SRC clojure 
    ; Ein Punkt besteht aus
    ; - einer Zahl für die X-,
    ; - einer Zahl für die Y-Koordinate
    ; ->punkt : number number -> punkt
    ; :x :      punkt -> number
    ; :y :      punkt -> number
    (defrecord punkt 
      [x y])
#+END_SRC

** Record-Benutzung in Clojure

#+BEGIN_SRC clojure 
user> (defrecord punkt [x y])
;; => user.punkt
user> (->punkt 2 3)
;; => #user.punkt{:x 2, :y 3}
user> (:x (->punkt 2 3))
;; => 2
user> (:y (->punkt 2 3))
;; => 3
user> (instance? punkt (->punkt 2 3))
;; => true
user> 
#+END_SRC

** Strukturverarbeitende Funktionen 
Beispiel: Berechnung der Entfernung eines Punktes vom Ursprung

#+BEGIN_SRC clojure
(use 'clojure.test)
;; Abstand eines Punktes vom Ursprung berechnen
;; abstand-vom-ursprung: punkt -> number
(def abstand-vom-ursprung
  (fn [p]
    {:pre  [(instance? punkt p)]
     :post [(number? %)]}
    (Math/sqrt
     (+ (* (:x p) (:x p))
        (* (:y p) (:y p))))))
;; Tests
(deftest test-absabstand-vom-ursprung
  (is (= (* 0.01 (Math/round (* 100 (abstand-vom-ursprung (->punkt 2 2)))))
         2.83)))
(run-tests)
#+END_SRC

* Entwurfsvorschrift III -- Strukturverarbeitende Funktionen
Die vier
Phasen der Entwurfsvorschrift I werden wieder um eine Phase
/Datenanalyse/ ergänzt, der Phase /Funktionsrumpf/ wird eine Phase
/Funktionsschablone/ vorgeschaltet:

1. Vertrag, Funktionskopf, Zweckbestimmung

2. *Datenanalyse/Datendefinition*

3. Beispiele / Tests

4. *Funktionsschablone*

5. Funktionsrumpf

6. Testen

Es folgt die Beschreibung der neuen bzw. angepassten Phasen.

** Entwurfsvorschrift III - Phase 2

Datenanalyse/Datendefinition

-  Ziel: Entwicklung einer adäquaten Datenstruktur

-  Aktivitäten:

   -  beschreibe die Datenstruktur in der Form:

      ; Ein $s$ besteht aus\\
      ; - einem /t/ für die /s_1/-Komponente,\\
      ; - \(\ldots\)\\
      ; ->s  : ($t \dots$ -> $s$) \\
      ; :s_1 : ($s$ -> $t$))\\
      ...

   -  definiere die Datenstruktur:\\
      (defrecord $s$ [$s_1$ ...])

** Entwurfsvorschrift III - Phase 4

Funktionsschablone

-  Ziel: Bestimmung der für die Berechnung des Ergebnisses
   erforderlichen Selektoren („Getter”) bzw. Konstruktoren.

-  Aktivitäten:

   -  Für jede Komponente der Datenstruktur, von deren Wert das Ergebnis
      der Funktion abhängt, schreibe den zugehörigen Selektor in die
      Funktionsschablone.

   -  Falls die Funktion eine Datenstruktur als Resultat liefern muss,
      nimm den Aufruf des Konstruktors in die Schablone mit auf.

#+BEGIN_SRC clojure
    (def verarbeite-punkt-zu-neuem-punkt
      (fn [p]
        (-> ...
          (... (:x p) ...
           ... (:y p) ...))))
#+END_SRC

* Gemischte Daten

** Datenabstraktion durch Generalisierung

-  Funktionen sollen verschiedene -- aber verwandte -- Datenstrukturen
   verarbeiten.

-  Beispiel: Rechtecke und Kreise sind geometrische Figuren.

   #+begin_small
   #+BEGIN_SRC clojure
       ; Eine figur ist entweder
       ; - ein Rechteck  
       ;     (->rechteck b h)
       ; oder
       ; - ein Kreis
       ;     (->kreis r)
   #+END_SRC
   #+end_small
-  Ein Wert, der zum Vertrag =figur= passt, muss entweder den Vertrag
   von =rechteck= oder von =kreis= erfüllen.

-  =figur= setzt natürlich die Definition von =rechteck= und =kreis=
   voraus.

** Definition von =rechteck=

#+BEGIN_SRC clojure
(use 'clojure.test)

;; Eine Rechteck besteht aus
;; - einer Zahl für die Höhe,
;; - einer Zahl für die Breite
;; ->rechteck:  number number -> rechteck
;; :breite :    (rechteck -> number))
;; :hoehe :     (rechteck -> number)

(defrecord rechteck
    [breite hoehe])

;; Rechteckfläche berechnen
(def rechteck-flaeche
  (fn [r]
    {:pre  [instance? rechteck r]
     :post [number? %]}
    (* (:breite r) (:hoehe r))))

(deftest test-rechteck 
  (is (= (rechteck-flaeche (->rechteck 3 4)) 12)))

(run-tests)
#+END_SRC


** Definition von =kreis=

#+BEGIN_SRC clojure 
(use 'clojure.test)

;; Ein Kreis besteht aus
;; - einer Zahl für den Radius,
;; ->kreis:  number -> kreis
;; :radius : kreis -> number

(defrecord kreis
    [radius])

;; Rechteckfläche berechnen
(def kreis-flaeche
  (fn [k]
    {:pre  [instance? kreis k]
     :post [number? %]}
    (* (:radius k) (:radius k) 3.14159)))

(deftest test-kreis 
  (is (= (* 0.01 (Math/round (* 100  (kreis-flaeche (->kreis 1.0))))) 3.14)))
(run-tests)
#+END_SRC

** Flächeninhalt von Figuren

#+BEGIN_SRC clojure
(use 'clojure.test)

;; Eine figur ist entweder
;; - ein Rechteck  
;;     (->rechteck b h)
;; oder
;; - ein Kreis
;;     (->kreis r)
(def figur-flaeche
  (fn [f]
    {:pre [or (instance? rechteck f)
              (instance? kreis f)]
     :post [number? %]}
    (cond
      (instance? kreis f)
      (kreis-flaeche f)
      (instance? rechteck f)
      (rechteck-flaeche f))))

(deftest test-figuren 
  (is (= (* 0.01 (Math/round (* 100  (figur-flaeche (->kreis 1.0))))) 3.14))
  (is (= (figur-flaeche (->rechteck 3 4)) 12)))
(run-tests)
#+END_SRC

* Entwurfsvorschrift IV -- Verarbeitung gemischter Daten
Diese
Entwurfsvorschrift stellt die „Verschmelzung” der Entwurfsvorschriften
II und III dar. Wenn sich in der Phase /Datenanalyse/ herausstellt, dass
gemischte Daten zu verarbeiten sind, ergibt sich für eine gemischte
Daten verarbeitende Funktion eine Fallunterscheidung nach dem Typ der
Daten. Damit handelt es sich um eine bedingte Funktion.

Die Phasen von Entwurfsvorschrift III bleiben erhalten.:

#+REVEAL: split
1. Vertrag, Funktionskopf, Zweckbestimmung

2. *Datenanalyse/Datendefinition*

3. Beispiele / Tests

4. *Funktionsschablone*

5. Funktionsrumpf

6. Testen

Es folgt die Beschreibung der neuen bzw. angepassten Phasen.

** Entwurfsvorschrift IV - Phase 2

*Datenanalyse/Datendefinition*

-  Ziel: Entwicklung einer adäquaten Datenstruktur

-  Aktivität: Beschreibe die Datenstruktur in der Form:

   ; Ein $s$ ist entweder\\
   ; - ein $t_1$ oder\\
   ; - $\ldots$ oder\\
   ; - ein $t_n$

-  Für den Vertrag:
   #+BEGIN_SRC clojure  
   {:pre [(or (instance? t-1 s)
              ...
              (instance? t-n s))]}
   #+END_SRC

** Entwurfsvorschrift IV - Phase 4

*Funktionsschablone*

-  Ziel: Konstruktion der Fallunterscheidung nach der Art der Daten

-  Aktivitäten:

   -  Lege die folgende Funktionsschablone an:

#+BEGIN_SRC clojure
    (def f
      (fn [x]
        {:pre [(or (instance? t-1 x)
                   (instance? t-2 x)
                    ...
                   (instance? t-n x))]
         :post [...]}
        (cond
           (instance? t-1 x) ...
           (instance? t-2 x) ...
           ...
           (instance? t-n x) ...)))
#+END_SRC

* Exkurs: Algebraische Datentypen
** Produkttypen
+ Die in Kapitel [[Datenstrukturen][Datenstrukturen]] erläuterten Strukturdefinitionen
  nennt man of auch /Produkte/.
+ Die Menge aller Exemplare der Record-Definition =punkt=
  (vgl. [[Record-Definition in Clojure]]) kann man als als Teilmenge des
  kartesischen Produkts 
  $$number \times number$$
  angesehen werden.
+ Daher die Bezeichnung /Produkttypen/.
** Summentypen
+ Die in Kapitel [[Gemischte Daten]] eingeführten varianten Typen
  #+BEGIN_QUOTE
     Eine Figur ist entweder ein Rechteck oder ein Kreis.
     #+END_QUOTE
  werden auch als Summentypen bezeichnet.
+ Die Menge aller Figuren ist die Vereinigung der Menge aller Kreise
  mit der Menge aller Rechtecke.
+ Die /Vereinigung von Mengen/ wird auch als die /Summe der Mengen/
  bezeichnet.
+ Daher die Bezeichnung Summentypen.

*** Haskell
Der Begriff der algebraischen Datentypen ist inbesondere im Kontext
der Programmiersprache [[https://www.haskell.org][Haskell]] sehr gebräuchlich.
* Exkurs: Funktionale vs. objektorientierte Programmierung

** Objektorientierte Programmierung ...
... ist gekennzeichnet durch dynamische Bindung und Polymorphie

Polymorphie-Ansatz der meisten OO-Sprachen:

-  Methoden werden innerhalb von Klassen definiert.
-  Methodenaktivierung durch „Senden von Nachrichten”: Die zu
   aktivierende Methode wird anhand der Klassenzugehörigkeit des
   Empfängerobjekts bestimmt.
#+begin_small
#+BEGIN_SRC java
          class Rechteck {
             int breite, hoehe;
             int flaeche() { ... }}
   
          class Kreis {
             int radius;
             int flaeche() { ... }}
#+END_SRC
#+end_small
-  Jeder „Datentyp” definiert seine Operationen.
-  *Problem*: Datentypen können ohne Zugriff auf den Quellcode nicht
   erweitert werden.

** Funktionale Programmierung ...
... ist gekennzeichnet durch Funktionen als Werte erster Ordnung und die Abwesenheit von
Seiteneffekten

-  Funktionen enthalten Fallunterscheidungen für Datentypen.

   #+begin_small
   #+BEGIN_SRC clojure
   (def figur-flaeche
     (fn [f]
       (cond
         (instance? kreis f)
         (kreis-flaeche f)
         (instance? rechteck f)
         (rechteck-flaeche f))))
   #+END_SRC
   #+end_small

-  *Problem*: Hinzufügen eines neuen Datentyps bedeutet: Alle vorhanden
   Figur-Funktionen müssen angepasst werden.

** Das Expression-Problem
+ Die Weiterentwicklung von Programmen betrifft
  + das Hinzufügen von Operationen für bestehende Datentypen (Klassen)
    und
  + das Hinzufügen von Datentypen für bestehende Operationen.
+ Dabei soll möglichst vermieden werden, bestehenden Code zu ändern
  oder neu zu kompilieren.
+ Der Ausdruck /expression problem/ stammt von [[https://en.wikipedia.org/wiki/Philip_Wadler][Philip Wadler]] ([[//www.daimi.au.dk/~madst/tool/papers/expression.txt][The
  ExpressionProblem Philip Wadler, 12 November 1998)]]
+ Lösungen
  + Haskells Typklassen
  + Rubys /open classes/
  + Smalltalks /class extensions/
  + Clojures /protocols/
