#+SETUPFILE: /Users/johannes/Documents/myOrg/org-html-themes/setup/theme-bigblow.setup
#+TITLE: Programmierparadigmen
#+AUTHOR: Johannes Brauer
#+OPTIONS:   H:4
#+OPTIONS: num:nil
#+OPTIONS: toc:nil
#+Language:  de
#+STARTUP: latexpreview
#+STARTUP: inlineimages
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_THEME: solarized
#+REVEAL_TRANS: none
# #+REVEAL_SLIDE_FOOTER: Prof. Dr.-Ing. Johannes Brauer: Programmierparadigmen
#+REVEAL_MARGIN: 0.05
#+REVEAL_EXTRA_CSS: file:///Users/Shared/Dropbox/Programmierparadigmen/mystyle.css
# um Folien mit reveal.js erzeugen zu können:
# M-x load-library und dann ox-reveal

* Inhaltsideen
+ funktionale Programmierung
+ logische Programmierung
+ Contraint Programming
+ Datalog/Datomic
* Metadaten
** Umfang/Semester
+ 40 Uh / 5
+ 40 Uh / 6
+ 7 ECTS
** Prüfungsform
+ Klausur
** Ziele
*** Qualifikationsziel: Verständnis von mathematischen und formalen Grundlagen der Informatik
  + Modulziel:
    Absolventen kennen die mathematischen Grundlagen der funktionalen
    und prädikativen Programmierung. 

*** Qualifikationsziel: Kenntnisse und Fertigkeiten zur algorithmischen Formulierung von Problemlösungen und ihrer Umsetzung in verständliche und effiziente Computerprogramme  
  + Modulziele:
    + Entwicklung der Fähigkeit, korrekte Programme systematisch zu entwickeln
    + Entwicklung der Fähigkeit, fortgeschrittene Programmiertechniken anzuwenden
    + Entwicklung der Fähigkeit den Nutzen verschiedener Programmierstile zu erkennen

*** Qualifikationsziel: Befähigung zum Einsatz professioneller Methoden und Werkzeuge zur Softwareentwicklung
    + Modulziel:
      Absolventen kennen innovative Methoden der professionellen Softwareentwicklung.
** Lerninhalte lt. Modulhandbuch
*** Gegenüberstellung der klassischen Programmierparadigmen:
  + imperative Programmierung 
  + funktionale Programmierung 
  + prädikative Programmierung
*** Funktionale Programmierung
  + Funktionsbegriff / funktionale Abstraktion
  + Programmieren mit Funktionen
  + Methodische Abstraktion: Entwurfsvorschriften à Funktionen hˆherer Ordnung
  + weitere funktionale Programmiertechniken
*** Prädikative Programmierung
  + Grundlagen
  + Programmiertechniken
  + Anwendungen
  + Prolog
*** Erweiterung der prädikativen Programmierung 
  + Constraint-Programmierung

* Einstieg
** Beispiele
*** Interpretieren Sie diesen Programmcode:
#+BEGIN_SRC clojure
(defn power [x y]
   (if (= y 0) 1
       (* x (power x (- y 1)))))
#+END_SRC
*** Aufgabe
Schreiben Sie eine statische Java-Methode, die ein Array von doubles
als Argument akzeptiert und den Durchschnitt der Zahlen liefert.

*** Lösung
#+begin_small
#+BEGIN_SRC java
  public static double average (double[] numbers) {
    double sum = 0;
    for (int i = 0; i < numbers.length; i++) {
      sum += numbers[i];
    }
    return sum / numbers.length;
  }
#+END_SRC
#+end_small

  versus

#+begin_small
#+BEGIN_SRC clojure
 (defn average
  [numbers]
  (/ (apply + numbers) (count numbers)))
#+END_SRC
#+end_small

*** Aufgabe
Gegeben ist eine Liste mit Preisen:

#+BEGIN_SRC java
final List<BigDecimal> prices = Arrays.asList(
  new BigDecimal("10"), new BigDecimal("30"), new BigDecimal("17"),
  new BigDecimal("20"), new BigDecimal("15"), new BigDecimal("18"),
  new BigDecimal("45"), new BigDecimal("12"));
#+END_SRC

Schreiben Sie Java-Code, der alle Preise größer als 20, rabattiert um
10%, aufsummiert.

*** Lösung
**** Java < 8
#+BEGIN_SRC java
BigDecimal totalOfDiscountedPrices = BigDecimal.ZERO;

for(BigDecimal price : prices) {
  if(price.compareTo(BigDecimal.valueOf(20)) > 0)
    totalOfDiscountedPrices =
       totalOfDiscountedPrices.add(price.multiply(BigDecimal.valueOf(0.9)));
}
#+END_SRC
**** Java 8
#+BEGIN_SRC java
final BigDecimal totalOfDiscountedPrices =
  prices.stream()
        .filter(price -> price.compareTo(BigDecimal.valueOf(20)) > 0)
        .map(price -> price.multiply(BigDecimal.valueOf(0.9)))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
#+END_SRC

**** Clojure
#+BEGIN_SRC clojure
(def prices (map bigdec [10 30 17 20 15 18 45 12]))

(def totalOfDiscountedPrices
  (reduce + 0
          (map (fn [p] (* p 0.9M))
               (filter (fn [p] (> p 20M))
                       prices))))

;; oder syntaktisch gezuckert
(def totalOfDiscountedPrices2
  (->> prices
       (filter #(> % 20M))
       (map    #(* % 0.9M))
       (reduce + 0)))
#+END_SRC

**** ????
#+BEGIN_SRC smalltalk
prices :=  #(10.0s 30.0s 17.0s 20.0s 15.0s 18.0s 45.0s 12.0s).

totalOfDiscountedPrices :=
((prices select: [:p | p > 20.0s])
          collect: [:p | p * 0.9s])
          fold: [:sum :p| sum + p]
#+END_SRC
*** Aufgabe: Mehr Geld bitte!
Sie senden einen Brief an Ihre Eltern mit dem Inhalt:
#+BEGIN_EXAMPLE 
             SEND
            +MORE
            -----
            MONEY
#+END_EXAMPLE
Wieviel Geld erhalten Sie?

Die Aufgabe besteht darin, jedem Buchstaben aus $\{S,E,N,D,M,O,R,Y\}$
eine unterschiedliche Ziffer aus $\{0,...,9\}$ zuzuordnen, so dass die
Gleichung 
$$SEND+MORE=MONEY$$
erfüllt wird.

*Aufgabe*: Lösen Sie das Problem in einer Programmiersprache Ihrer
Wahl! Beachten Sie Nebenbedingungen.

*** Lösungsansatz: „Rohe Gewalt“
+ Alles durchprobieren!
+ Man braucht 8 ineinander geschachtelte Schleifen.
+ Achtung: Acht Variablen (=S,E,N,D,M,O,R,Y=) können zehn verschiedene
  Werte annehmen. Ergibt $10^{8}$ Möglichkeiten.
+ Allerdings verringern einschränkende Bedingungen die Zahl der Möglichkeiten:
  + =S= und =M= dürfen nicht $0$ sein.
  + Da =M= als Übertrag entsteht, kann =M= nur $1$ sein.
  + Die Werte der Variablen müssen paarweise verschieden sein.
+ Weitere logische Überlegungen über Zusammenhänge zwischen den
  Ziffern können das Verfahren beschleunigen (s.\nbsp{}u.).
+ Lösung z.\nbsp{}B. in Smalltalk:
#+REVEAL: split
#+attr_html: :font-size 20px
#+BEGIN_SRC java
| z1 z2 z3 used |
used := Set new.
1 to: 9 do: [:s | 
   used add: s.
   0 to: 9 do: [:e | 
      (used includes: e)  ifFalse: [
          used add: e.
          0 to: 9 do: [:n | 
             (used includes: n)  ifFalse: [
                used add: n.
                0 to: 9 do: [:d | 
                   (used includes: d) ifFalse: [
                      used add: d.
                      1 to: 1 do: [:m |
                         (used includes: m)  ifFalse: [
                            used add: m.
                            0 to: 9 do: [:o | 
                               (used includes: o) ifFalse: [
                                  used add: o.
                                  0 to: 9 do: [:r | 
                                     (used includes: r) ifFalse: [
                                        used add: r.
                                        0 to: 9 do: [:y | 
                                           (used includes: y) ifFalse: [ 
                                              z1 := 1000 * s + (100 * e) 
                                                    + (10 * n) + d.
                                              z2 := 1000 * m + (100 * o) 
                                                    + (10 * r) + e.
                                              z3 := 10000 * m + (1000 * o) 
                                                    + (100 * n) 
                                                    + (10 * e) + y.
                                              z1 + z2 = z3 ifTrue: [
					         Transcript 
                                                   show: '   ',z1 printString; cr; 
                                                   show: '+',z2 printString; cr; 
                                                   show: '---------';cr;
                                                   show: z3 printString; cr]]].
                                        used remove: r ]].
                                  used remove:o ]].
                            used remove: m ]]. 
                      used remove: d]].
                used remove: n]].
          used remove: e]].            
    used remove:s]. 
#+END_SRC
#+REVEAL: split
Resultat:
#+BEGIN_EXAMPLE
  9567
+ 1085
------
 10652
#+END_EXAMPLE
*** Lösungsansatz: Constraint Satisfaction
+ Einfaches Modell durch Spezifikation der folgenden Gleichung als Einschränkung:
    $$1000*S+100*E+10*N+D $$
    $$+ 1000*M+100*O+10*R+E $$
    $$= 10000*M+1000*O+100*N+10*E+Y$$
+ Den Variablen $E, N, D, O, R, Y$ wird die Domäne $\{0 \ldots 9\}$, 
    der Variablen $S$ die Domäne $\{1 \ldots 9\}$ und $M$ die Domäne 
    $\{1\}$ zugeordnet.
+ Außerdem muss die Einschränkung 
  $all\_different([S,E,N,D,M,O,R,Y])$ hinzugefügt werden.
+ Das Modell ist nicht effizient, weil alle Variablen bis auf eine
  schon belegt sein müssen, bevor die „Haupteinschränkung”
  geprüft werden kann.

*** Verfeinertes CSP-Modell
+ Nutzung der Überträge der Addition für die Zerlegung der „großen“
  Einschränkung in mehrere kleine:
         \begin{eqnarray*}
            E+D & = & Y+10*C1  \\
            C1+N+R & = & E+10*C2  \\
            C2+E+O & = & N+10*C3  \\
            C3+S+M & = & 10*M+O
        \end{eqnarray*}
+ Die Domänen der Variablen:
         \begin{eqnarray*}
            E,N,D,O,R,Y & := & \{0,\ldots,9\} \\
                    S & := & \{1,\ldots,9\} \\
                    M & := & \{1\} \\
               C1,C2,C3 & := & \{0,1\}   
        \end{eqnarray*}
+ Die „kleinen“ Einschränkungen werden während
  der Belegungsphase früher geprüft und damit inkonsistente Belegungen
  ausgesondert.

** Software-Technik -- eine unreife Technologie?

*** Hat die Software-Technik ein Problem?

fragt cite:AmitRathore2012
# \cite{AmitRathore2012}:

-  Warum ist kein Software-Projekt so einfach wie es scheint?

-  Warum wird kein Software-Projekt rechtzeitig und unter Einhaltung des
   Budgets fertig?

-  Warum hat jede nicht-triviale Software Fehler?

-  Warum tut Software oft nicht das, was sie tun soll?

-  Warum ist es so schwierig, Änderungen an Software vorzunehmen?

-  Gleichgültig, wie klar der Plan eines Projekts zu Beginn war, warum
   wird daraus am Ende immer ein riesiger Haufen Morast?

-  Alle kennen das Problem und scheinen es zu akzeptieren!?

-  Die Software-Industrie reagiert mit Puffern für Zeit und Budget und
   der Akzeptanz mittelmäßiger Software!?

*** Viele Software-Projekte werden durch falsche Annahmen von vornherein gefährdet.

So ist es meistens falsch, anzunehmen, dass

-  der Anwender bei Projektbeginn genau weiß, was er will,

-  der Anwender das, wovon er weiß, dass er es will, vollständig
   mitteilen kann,

-  der Entwickler ausreichend verstanden hat, was der Anwender mitteilen
   konnte,

-  das kommunizierte Wissen ausreicht, um die vom Anwender gewollten
   Funktionen produzieren zu können,

-  der Entwickler eine wissenschaftlich begründete Methode besitzt, um
   das Verstandene in Software zu übertragen,

-  der Anwender versteht, was der Entwickler außer den vorgelegten
   Beispielen noch leisten könnte,

-  der Anwender also wüsste, welche Software möglich wäre, wenn der
   Entwickler besser über seine Bedürfnisse unterrichtet wäre.

*** Ein „berühmtes” Beispiel

*W. Gibbs in Scientific Armerican*:

-  1994 sollte der Denver International Airport als gigantisches,
   technisches Wunderwerk mit einem vollautomatischen unterirdischen
   Gepäcktransportsystem eingeweiht werden.

-  Die gesamte Hardware incl. 400 Telecars war pünktlich fertig; die
   Software fehlte.

-  Die Eröffnung musste immer wieder verschoben werden.

-  Neun Monate später konnte der Software-Hersteller noch keine Prognose
   zum Fertigstellungstermin abgeben.

*** Thomas C. Hales bemerkt in Formal Proof
cite:Hales2008
# (\cite{Hales2008})

-  On average, a programmer introduces *1.5 bugs per line while typing*.
   Most are typing errors that are spotted at once.

-  About* one bug per hundred lines of computer code ships to market
   without detection*.

-  Bugs are an accepted part of programming culture.

-  The book that describes itself as the „bestselling software testing
   book of all time“ states that „testers shouldn't want to verify that
   a program runs correctly“.

-  Another book on software testing states „Don't insist that every bug
   be fixed ... When the programmer fixes a minor bug, he might create a
   more serious one.“

-  Corporations may keep critical bugs off the books to limit legal
   liability. Only those bugs should be corrected that affect profit.
   *The tools designed to root out bugs are themselves full of bugs.*

*** Software besteht aus Millionen Code-Zeilen
-  die einzige Sicht: Programmtext
-  Baumstruktur links zeigt nicht die Abhängigkeit der Komponenten.

#+attr_html: :width 600px
[[./Abbildungen/MillionLoc.png]]

*** Software ist unsichtbar
#+attr_html: :width 600px
#+ATTR_ORG: :width 10%
[[./Abbildungen/SwAuto.png]]

*** Beispiel zur Schärfung des Problembewusstseins

-  Aufgabenstellung (in Anlehnung an cite:KlaerenSperber2007)
# \cite{KlaerenSperber2007})):

   #+BEGIN_QUOTE
     Auf einem Parkplatz stehen Personenkraftwagen und Motorräder ohne
     Beiwagen. Zusammen seien es $n$ Fahrzeuge mit insgesamt $m$ Rädern.
     Bestimme die Anzahl $P$ der PKWs!
   #+END_QUOTE

-  Typische informelle Problemspezifikation.

-  Gesucht ist eine Berechnungsvorschrift für die Funktion $P(n, m)$.

-  Wie kann der Zusammenhang zwischen der Anzahl der PKWs $P(n,m)$, der
   Anzahl der Motorräder $M(n,m)$, der Anzahl der Räder $m$ und der
   Anzahl der Fahrzeuge $n$ formuliert werden?

#+ATTR_REVEAL: :frag roll-in
   $$\begin{aligned}
           P + M = n \\  4P + 2M = m
         \end{aligned}$$

*** Beispiel zur Schärfung des Problembewusstseins (2)

#+ATTR_REVEAL: :frag (none roll-in)
-  Lösung des Gleichungssystems:

   \begin{eqnarray*}
          M & = & n - P \\
        4P + 2(n-P) & = & m\\
        4P + 2n - 2P & = & m \\
        2P & = & m- 2n\\
        P & = & \frac{m-2n}{2}
         \end{eqnarray*}
-  Problem scheinbar gelöst. Formel könnte in ein Programm übersetzt
   werden. ABER: Was liefert die Formel für $n=3$ und $m=9$?

   \begin{aligned}
           P(3,9) = \frac{9-2\cdot 3}{2} = 1,5
         \end{aligned}
   Anderthalb PKWs stehen auf dem Parkplatz!

*** Beispiel zur Schärfung des Problembewusstseins (3)

#+ATTR_REVEAL: :frag (none none roll-in roll-in roll-in roll-in roll-in)
- Schlussfolgerung: $m$ muss gerade sein.

- ABER: Was liefert die Formel für $n=5$ und $m=2$?

- \begin{aligned}
        P(5,2) = \frac{2-2\cdot 5}{2} = -4
  \end{aligned}
  Vier PKWs „fehlen“ auf dem Parkplatz!

- Schlussfolgerung: Die Anzahl der Räder muss mindestens doppelt so
  groß sein wie die Anzahl der Fahrzeuge.

- ABER: Was liefert die Formel für $n=2$ und $m=10$?

- \begin{aligned}
        P(2,10) = \frac{10-2\cdot 2}{2} = 3
      \end{aligned}

- Problem: Unsinnigkeit des Ergebnisses nicht sofort erkennbar. (Wenn
  3 von 2 Fahrzeugen PKWs sind, muss es noch ein „negatives” Motorrad
  geben.) 

*** Beispiel zur Schärfung des Problembewusstseins (4)

-  Schlussfolgerung: Die Anzahl der Räder darf höchstens viermal so groß
   sein wie die Anzahl der Fahrzeuge.

-  Fazit:

   -  Die Problemspezifikation ist unvollständig. Das „Programm“
      liefert nur dann sinnvolle Ergebnisse, wenn folgende Bedingung
      gilt: $$m \mbox{ gerade und } 2n\leq m \leq4n$$
      *Aufgabe*: Begründen Sie, warum mit dieser Bedingung die Lösung
      des Gleichungssystems die folgenden Anforderungen erfüllt:

      -  $P$ ist eine ganze Zahl.

      -  $P$ wird nicht negativ.

      -  $P$ wird nicht größer als $n$.

   -  Fehlerhafte Abstraktion: In der mathematischen Formel sind $m$ und
      $n$ irgendwelche Zahlen, auf dem Parkplatz aber nicht.

** Was ist ein Paradigma?
Das Wort Paradigma leitet sich vom griechischen Wort παράδειγμα
(parádeigma) ab, das (lt. Menge-Güthling) übersetzt /Beispiel/ oder
/Vorbild/ bedeutet.

Laut Duden sind Synonyme: [Fall]beispiel, Leitbild, Modell[fall],
Muster[beispiel], Musterbild, Vorbild; (bildungssprachlich)
Inkarnation, Prototyp; (bildungssprachlich veraltend) Exempel 

Häufig wird das Wort im Sinne von /Denkmuster/ gebraucht.

** Was ist ein Programmierparadigma?
*** Begriffsbestimmung
Antwort lt. [[https://de.wikipedia.org/wiki/Programmierparadigma][Wikipedia]]: ein fundamentaler Programmierstil

Was ist ein Programmierstil?

Antwort lt. [[https://de.wikipedia.org/wiki/Programmierstil][Wikipedia]]: „Ein Programmierstil (engl. code conventions,
coding conventions, coding standards) ist in der Programmierung das
Erstellen von Quellcode nach bestimmten vorgegebenen Regeln.“

*** übliche Klassifikationen
+--------------------------------+------------------------------+
|   Imperative Programmierung    | Deklarative Programmmierung  |
+--------------+-----------------+---------------+--------------+
|Prozedurrale  |Objektorientierte|Funktionale    |Logische      |
|Programmierung|Programmierung   |Programmierung |Programmierung|
+--------------+-----------------+---------------+--------------+

+ Imperativ Programmieren heißt, zu beschreiben, *wie* die Lösung eines
  Problems zu erzielen ist.
+ Deklarativ Programmieren heißt, zu beschreiben, *was* das zu lösende
  Problem ist.

** Die „klassischen” Programmierparadigmen

-  Imperative Programmierung
   -  Grundkonzepte: Variablen, Wertzuweisungen
   -  Programm = Folge von Anweisungen, die eine Zustandsänderung
      bewirken
   -  Strukturierte Sprachen
   -  Modulare Sprachen
   -  Objektorientierte Sprachen
   -  Hybride Sprachen

-  Funktionale (applikative) Programmierung
   -  Grundkonzept: Funktion i.S.d. Mathematik
   -  Programm = Ausdruck, der einen Wert als Ergebnis liefert
      #+BEGIN_EXAMPLE
                  (defn power [x y]
                     (if (= y 0) 1
                         (* x (power x (- y 1)))))
      #+END_EXAMPLE

#+REVEAL: split
-  Logische (prädikative) Programmierung
   -  Grundkonzept: Formale, mathematische Logik
   -  Beispiel: Sprache Prolog mit Fakten und Regeln
      
      Fakten:
      -  Hans ist direkter Chef von Franz.
      -  Franz ist direkter Chef von Heinz.
      -  =direkterChef(hans, franz).=
      -  =direkterChef(franz, heinz).=
      Regeln:
      -  Eine Person X ist Vorgesetzter von Y, wenn X direkter Chef von
         Y ist oder wenn X direkter Chef von Z und Z Vorgesetzter von Y
         ist.
      -  =vorgesetzter(X,Y):-direkterChef(X,Y).=
      -  =vorgesetzter(X,Y):-direkterChef(X,Z), vorgesetzter(Z,Y).=
	
*** Prozedurorientiertes vs. objektorientiertes Denken

(Darstellung angelehnt an cite:Moessenboeck
# \cite{Moessenboeck})

-  Prozedurorientiertes Denken: Algorithmen, Prozeduren stehen im
   Vordergrund, Daten sind „zweitrangig“.

-  Beispiel: Flächenberechnung vom geometrischen Figuren:
#+attr_html: :width 350px
[[./Abbildungen/flaechen.png]]

#+BEGIN_EXAMPLE
          flaeche := kreisFlaeche(kreis);
          flaeche := rechteckFlaeche (rechteck);
#+END_EXAMPLE

*** Merkmale der prozeduralen Programmierung

-  in konventionellen Sprachen für jede Figurart eigene Prozedur
   erforderlich

-  Fallunterscheidungen notwendig, wenn in einem Programm Figuren
   verschiedener Arten gleichzeitig vorkommen; sei z.B. $f$ eine
   beliebige geometrische Figur:

   #+BEGIN_EXAMPLE
         ...
         if f is Rechteck 
            then flaeche := rechteckFlaeche(f)
         elsif f is Kreis 
            then flaeche := kreisFlaeche(f)
         elsif f is Dreieck 
            then flaeche := dreiecksFlaeche(f)
         ...
   #+END_EXAMPLE

-  Warum sind solche Fallunterscheidungen problematisch?

*** Objektorientiertes Denken ...

... stellt die Daten in den Mittelpunkt der Betrachtung:

#+attr_html: :width 350px
[[./Abbildungen/objekte.png]]

#+BEGIN_EXAMPLE
     flaeche := f flaechenInhalt
     flaeche = f.flaechenInhalt();
#+END_EXAMPLE

*** Merkmale der Objektorientierten Programmierung:

-  Ein Objekt antwortet auf den Empfang einer Frage (einer Nachricht).

-  Das Figurobjekt „weiß selbst“ wie die Antwort (der Flächeninhalt) zu
   ermitteln ist.

-  Fallunterscheidungen werden weitgehend überflüssig.


*** Die Überbrückung der „Abstraktionslücke“

#+attr_html: :width 650px
[[./Abbildungen/Abstraktionsluecke.png]]

*** Bedeutung der Abstraktion in der Software-Technik

-  Komplexität von Softwaresystemen überfordert

   -  die Fähigkeit von Menschen, sie in Gänze zu erfassen,

   -  die Fähigkeit der Entwickler, sie so zu bauen, dass sie den
      Anforderungen in korrekter Weise entspricht.

-  Wenn ein Entwickler für eine Aufgabe sechs Monate benötigt, wie lange
   brauchen dann sechs Entwickler, wenn sie die Aufgabe gemeinsam
   erledigen sollen?

-  Ohne leistungsfähige Abstraktionskonzepte ist die Beherrschung von
   Komplexität unmöglich.

-  Die Zeit, die ein Programmierer benötigt, um eine Zeile Code zu
   schreiben, ist eine Konstante (unabhängig von der
   Programmiersprache).

-  Daher ist das Abstraktionsniveau der von einer Programmiersprache
   bereitgestellten Ausdrucksmittel entscheidend

   -  für die Beherrschung von Komplexität und

   -  die Produktivität der Programmierer.

*** Eine Bezahl-App 
Entwicklung beschrieben durch Wille Faler in
[[http://agile.dzone.com/news/one-night-clojure-makes-scala]]

„A simple metric generated with cloc“:

- Java version: 755 lines of code (LOC)

- Scala version: 200 LOC's

- Clojure version: 57 LOC's


* Funktionale Programmierung
** Programmieren mit Funktionen

*** Exkurs: Programmieren mit Funktionen /(1)/

-  Merkmale der imperativen Programmierung:
   1. Wesentliche Konzepte:
      -  Variablen: benannte Speicherzellen
      -  Zuweisung: Verändern des Wertes einer Variablen
   2. Die Werte der Variablen repräsentieren den Zustand der Maschine.
   3. Das Programm ist eine Folge von Zustandsänderungen.
   4. Im imperativen Programmierstil spiegelt sich die
      Von-Neumann-Architektur wider (hinderlich bei der Programmierung
      komplexer Anwendungen).
   5. Imperative Programme sind nicht referenztransparent: $f(x)+f(x)$
      ist nicht notwendigerweise gleich $2\cdot f(x)$.

*** Exkurs: Programmieren mit Funktionen / (2)/

-  Merkmale der funktionalen Programmierung:
   1. Gute mathematische Grundlage der Programmierung (Funktionsbegriff)
   2. Programme werden kürzer und besser lesbar.
   3. Verarbeitung komplexer (häufig symbolischer) Datenstrukturen
   4. Keine Variablen als benannte Speicherzellen
   5. Keine Iteration
   6. Funktionale Sprachen haben besondere Bedeutung für die Definition
      der Semantik von Programmiersprachen:
   7. z.B. durch Definition eines Interpreters, geschrieben in einer
      funktionalen Sprache.

** Ein erstes Beispiel

Tafelübung funktionale Abstraktion (fn) einführen

*** Eine einfache Funktion

-  Berechnung des Bruttobetrags einer Rechnung aus dem Nettobetrag:
   -  mathematisch\\
      $brutto(netto, mhrwrtstr) = netto + netto \frac{mhrwrtstr}{100}$
   -  Definition einer Funktion =brutto=:
      #+BEGIN_SRC clojure
          (def brutto
                (fn [netto mhrwrtstr]
                  (+ netto (/ (* netto mhrwrtstr) 100))))
      #+END_SRC

*** Aufbau von Ausdrücken
-  Jeder Ausdruck ist von der Form\\
   $$(operator\ operand_{1} \ldots\ operand_{n})$$
-  /Operatoren/ sind Namen von
   -  Standardfunktionen: +, /, =sqrt=, ...
   -  eigenen Funktionen: =brutto=, ...
   -  Pseudofunktionen: =def=, =fn=, ...
-  /Operanden/ sind
   -  Konstanten: 3.14, ...
   -  Variable: =netto=, ...
   -  Ausdrücke: =(f ....)=

*** Wert eines Ausdrucks

-  Anwendung einer Funktion auf ihre Argumente:\\
   =(brutto 100.0 16.0)=
-  Ersetze jedes Auftreten von =netto= durch 100.0 und von =mhrwrtstr=
   durch 16.0:\\
   == (+ 100.0 (/ (* 100.0 16.0) 100))=
-  Auswertung erfolgt von innen nach außen:\\
   == (+ 100.0 (/ (* 100.0 16.0) 100))=\\
   == (+ 100.0 (/ 1600.0 100))=
-  im nächsten Schritt:\\
   == (+ 100.0 (/ 1600.0 100))=\\
   == (+ 100.0 16.0))=
-  schließlich:\\
   == 116.0=

** Clojure

*** Eigenschaften von Clojure

Clojure ...
-  ist ein Lisp-Dialekt.
-  läuft auf der Java Virtual Machine.
-  ermöglicht verschiedene Programmierstile (imperativ, *funktional*,
   objektorientiert, ...).
-  behandelt Funktionen als Werte erster Ordnung (first class values),
   d.h. sie können u.a. ...
   -  als Argumente an Prozeduren/Funktionen/Methoden übergeben werden,
   -  als Resultate von Prozeduren/Funktionen/Methoden auftreten.
-  besitzt eine einzige Auswertungsregel für die Anwendung von
   Funktionen (Ausnahmen für Pseudofunktionen).

*** Web-Seiten zu Clojure
-  [[http://clojure.org][Hauptseite]]
-  [[http://clojure.org/features][Features]]
-  [[http://clojure.org/downloads][Download]]
-  Dokumentation
   -  [[http://clojuredocs.org][clojuredocs]]
   -  [[http://clojure-doc.org][clojure-doc]]
-  [[http://groups.google.com/group/clojure][Google Gruppe]]
-  Tutorials
   -  [[http://dev.clojure.org/display/doc/Getting+Started][Getting Started]]
   -  [[http://www.braveclojure.com][CLOJURE for the BRAVE and TRUE]]
   -  [[http://www.moxleystratton.com/blog/2008/05/01/clojure-tutorial-for-the-non-lisp-programmer/][Clojure Tutorial For the Non-Lisp Programmer]]
   -  [[http://java.ociweb.com/mark/clojure/article.html][Clojure - Functional Programming for the JVM]]

*** Benutzung von Clojure
-  [[http://try-clojure.org/][Try Clojure]]
-  Command line tool - the repl
   =java -cp clojure.jar clojure.main=
-  Clooj - editor and IDE written entirely in Clojure itself
   -  [[https://github.com/arthuredelstein/clooj][clooj, a lightweight IDE for clojure]]
   -  [[https://www.mediafire.com/?kxa2an0k0ings][Download]]
-  [[http://www.lighttable.com][LightTable]] is a new interactive IDE ...
-  [[http://leiningen.org/index.html][Leiningen]]
-  [[http://dev.clojure.org/display/doc/Getting+Started+with+La+Clojure+and+IntelliJ+IDEA][La Clojure and IntelliJ IDEA]]
-  [[http://dev.clojure.org/display/doc/Getting+Started+with+Eclipse+and+Counterclockwise][Eclipse and Counterclockwise]]
-  [[http://clojure-doc.org/articles/tutorials/emacs.html][Clojure with Emacs]]

*** Die Read-Eval-Print-Loop
-  Read: lies einen Ausdruck
-  Eval(uate): werte ihn aus
-  Print: gib das Ergebnis aus
#+attr_html: :width 650px
[[./Abbildungen/ReadEvalPrint.png]]

*** =brutto= in der Repl

Demonstration

** Methodische Abstraktion -- Entwurfsvorschrift I

*** Entwurfsvorschriften - Übersicht
-  /Entwurfsvorschriften/ sind Handlungsanleitungen für die Entwicklung
   kleiner (zunächst funktionaler) Programme.
-  Programmstrukturen folgen den Datenstrukturen.
-  Abstraktion von der Lösung von Einzelproblemen zur Lösung von
   Problemklassen.
-  Entwicklung funktionaler Programme:
   -  Funktionen im mathematischen Sinne:
      -  keine Nebeneffekte
      -  kein Gedächtnis (stateless)
   -  Nutzung der funktionalen Abstraktion

*** Entwurfsvorschrift I]Entwurfsvorschrift I /(1)/
Programm für die Berechnung der Fläche eines Dreiecks aus Grundseite und
Höhe:

1. die *Zweckbestimmung*:
#+BEGIN_SRC clojure
    ;; berechnet die Flaeche eines Dreiecks aus
    ;; Grundseite und Hoehe
#+END_SRC

2. Hinzufügen des *Funktionskopfs*
#+BEGIN_SRC clojure
    ;; berechnet die Flaeche eines Dreiecks aus
    ;; Grundseite und Hoehe
    \blue{(def dreiecksflaeche}
      \blue{(fn [grundseite hoehe]} 
          nil))
#+END_SRC
=nil= steht hier als Platzhalter für den Funktionsrumpf.

*** Entwurfsvorschrift I /(2)/ 
3. Festlegen des *Vertrags*:
#+BEGIN_SRC clojure
    ;; berechnet die Flaeche eines Dreiecks aus
    ;; Grundseite und Hoehe
    (def dreiecksflaeche
      (fn [grundseite hoehe]
    \blue{    \{:pre [(number? grundseite) (number? hoehe)]}
    \blue{     :post [(number? \%)]\}}
        nil))
#+END_SRC
4. Hinzufügen von *Beispielanwendungen / Tests*
#+BEGIN_SRC clojure
    ;; berechnet die Flaeche eines Dreiecks aus
    (def dreiecksflaeche
      (fn [grundseite hoehe]
        \{:pre [(number? grundseite) (number? hoehe)]
         :post [(number? %)]\} nil))
    \blue{(deftest test-dreiecksflaeche} 
    \blue{  (is  (= 25 (dreiecksflaeche 10 5))))}
#+END_SRC

*** Entwurfsvorschrift I /(3)/ 
5. Ersetzen von =nil= als Platzhalter im Funktionsrumpf durch die korrekte
Berechnungsvorschrift:
#+BEGIN_SRC clojure
    (def dreiecksflaeche
      (fn [grundseite hoehe]
        \{:pre [(number? grundseite) (number? hoehe)]
         :post [(number? %)]\}
    \blue{    (/ (* grundseite hoehe) 2)}))

    (deftest test-dreiecksflaeche 
      (is  (= 25 (dreiecksflaeche 10 5))))
#+END_SRC

*** =dreiecksflaeche= in Clooj

[[./Abbildungen/dreiecksflaecheInClooj.png]]

*** Entwurfsvorschrift I Zusammenfassung Vier Phasen:

1. Zweckbestimmung, Vertrag, Funktionskopf
2. Tests
3. Funktionsrumpf
4. Testen

*** Entwurfsvorschrift I - Phase 1 /(1)/

Zweckbestimmung, Vertrag, Funktionskopf
-  Ziele:
   -  Beschreiben des Zwecks der Funktionen
   -  Spezifizieren der Art der Eingabedaten und des Ergebnisses
   -  Benennen der Funktion
   -  Aufschreiben ihres Kopfes
-  Aktivitäten:
   -  Wähle einen Funktionsnamen.
   -  Analysiere das Problem daraufhin, welche unbestimmten Größen sie
      verarbeiten muss.
   -  Wähle einen Namen für jede Eingangsgröße, der sich möglichst in
      der Problembeschreibung wiederfindet.
   -  ...

*** Entwurfsvorschrift I - Phase 1 /(2)/

Vertrag, Funktionskopf, Zweckbestimmung
-  Aktivitäten:
   -  ...
   -  Beschreibe unter Verwendung der Namen für die Eingangsgrößen, was
      die Funktion aus diesen ermitteln soll.
   -  Formuliere den Vertrag und den Funktionskopf.
      #+BEGIN_SRC clojure
          ;; berechnet ... aus x1 ... 
                  (def name 
                     (fn [x1 ... ] 
                       \{:pre [(number? x1) ... ]
                        :post [(number? %)]\}
                       ... ))
      #+END_SRC

*** Entwurfsvorschrift I - Phase 2

Beispiele / Tests
-  Ziel: Veranschaulichung der Beziehung zwischen Ein- und Ausgabedaten
   anhand von Beispielen
-  Aktivitäten:
   -  Versuche, aus der Problembeschreibung Beispiele abzuleiten.
   -  Bestätige die Resultate.
   -  Schreibe die Beispiele als Tests auf.
      #+BEGIN_SRC clojure
          (def name 
                     (fn [x1 ... ] 
                       \{:pre [(number? x1) ... ]
                        :post [(number? %)]\}
                       ... ))
                  (deftest test-name (is (= (name ... ) ...)))        
      #+END_SRC

*** Entwurfsvorschrift I - Phase 3

Funktionsrumpf

-  Ziel: Definition der Funktion
-  Aktivitäten:
   -  Entwickle die Berechnungsvorschrift für die Ermittlung des
      Resultats bestehend aus
      -  Clojure-Standardfunktionen,
      -  eigenen Funktionen und
      -  den Variablen (Parameter).
   -  Wenn vorhanden, benutze die mathematische Formel aus der
      Problembeschreibung.

*** Entwurfsvorschrift I - Phase 4

Testen

-  Ziele: Aufspüren von
   -  Fehlern in der Berechnungsvorschrift,
   -  auch Tippfehler,
   -  Vertragsverletzungen in der Formulierung der Tests
-  Aktivitäten:
   -  Wende die Funktion auf die in den Beispielen angegebenen
      Eingabedaten (Argumente) an.
   -  Prüfe, ob die Resultate mit den erwarteten übereinstimmen
      (geschieht durch =(run-tests)= automatisch).
   -  Füge weitere Tests hinzu.

** Verwendung von Hilfsfunktionen

Hilfsfunktionen /(1)/

-  Problembeschreibung:
   Der Eigentümer eines Vorstadtkinos kann seine Preise für
   Eintrittskarten frei festlegen. Er hat einen exakten Zusammenhang
   zwischen dem Kartenpreis und der durchschnittlichen Besucheranzahl
   empirisch festgestellt: Bei einem Preis von pro Karte kommen im
   Schnitt 120 Zuschauer. Reduziert er den Preis um , erhöht sich die
   Besucherzahl um 15. Aber mehr Besucher verursachen höhere Kosten.
   Jede Veranstaltung kostet plus für jeden Zuschauer. Der Eigentümer
   möchte nun wissen, wie groß der Profit bei einem bestimmten
   Kartenpreis ist.

Hilfsfunktionen /(2)/

-  Können wir dem Kinoeigentümer helfen?

-  Versuchen wir zunächst die Abhängigkeiten zu erkennen, die sich aus
   der Problembeschreibung ableiten lassen:

[method=direct]Hilfsfunktionen /(3)/

-  Entwerfen wir nun für jeden Zusammenhang eine Funktion und wenden
   dabei die Entwurfsvorschrift an.

-  Danach ist in Phase 1 zunächst der Vertrag, der Funktionskopf und die
   Zweckbestimmung aufzuschreiben.

-  Beginnen wir mit der Hauptfunktion für den Profit:

   #+BEGIN_SRC clojure
       ;; berechnet den Profit aus der Differenz zwischen
       ;; Einnahmen und Kosten bei gegebenem Kartenpreis
       (def profit
         (fn [kartenpreis]
           \{:pre [(number? kartenpreis)]
            :post[(number? %)]\}
           ...))
               
           
   #+END_SRC

[method=direct]Hilfsfunktionen /(4)/

-  Die Berechnung der Einnahmen:

   #+BEGIN_SRC clojure
       ;; berechnet die Einnahmen aus dem Produkt von 
       ;; Besucherzahl und Kartenpreis
       (def einnahmen
         (fn [kartenpreis]
           \{:pre [(number? kartenpreis)]
            :post[(number? \%)]\}
           ...))
   #+END_SRC

-  Die Kosten:

   #+BEGIN_SRC clojure
       ;; berechnet die entstehenden Kosten bei gegebenem
       ;; Kartenpreis aus Fixkosten und variablen Kosten
       (def kosten
         (fn [kartenpreis]
           \{:pre [(number? kartenpreis)]
            :post [(number? \%)]\}
          ...))
   #+END_SRC

[method=direct]Hilfsfunktionen /(5)/

-  Die Anzahl der Besucher:

   #+BEGIN_SRC clojure
       ;; berechnet die Besucherzahl bei gegebenem
       ;; Kartenpreis nach empirisch ermittelter Formel
       (def besucherzahl
         (fn [kartenpreis]
           \{:pre [(number? kartenpreis)]
            :post [(number? \%)]\}
          ...))
   #+END_SRC

Hilfsfunktionen /(6)/

-  In Phase II versuchen wir Beispiele zu finden; beginnen wir mit der
   Funktion =besucherzahl=.

-  Aus der Problembeschreibung lassen sich folgende Beispiele ableiten:

   -  (besucherzahl 500) = 120

   -  (besucherzahl 490) = 135

   -  (besucherzahl 510) = 105

   -  (besucherzahl 400) = 270

-  Hinweis: Um Rundungsfehler zu vermeiden, werden alle Beträge in Cent
   angegeben.

-  Lässt sich aus den Beispielen ein allgemeiner Zusammenhang ableiten?

-  Antwort: (besucherzahl p) = (+ 120 (* (/ 15 10) (- 500 p)))

[method=direct]Hilfsfunktionen /(7)/

-  Die Funktion =besucherzahl= ergibt sich somit zu:

   #+BEGIN_SRC clojure
       ;; berechnet die Besucherzahl bei gegebenem
       ;; Kartenpreis nach empirisch ermittelter Formel
       (def besucherzahl
         (fn [kartenpreis]
           \{:pre [(number? kartenpreis)]
            :post [(number? \%)]\}
          {\blue(+ 120 (*(/ 15 10 ) (- 500 kartenpreis)))}))

       {\red (deftest test-besucherzahl}
       {\red   (is (= (besucherzahl 500) 120))}
       {\red   (is (= (besucherzahl 490) 135))}
       {\red   (is (= (besucherzahl 510) 105))}
       {\red   (is (= (besucherzahl 400) 270)))}
   #+END_SRC

[method=direct]Hilfsfunktionen /(8)/

-  Für die Funktion =kosten= gehen wir ähnlich vor und erhalten
   schließlich:

   #+BEGIN_SRC clojure
       ;; berechnet die entstehenden Kosten bei gegebenem
       ;; Kartenpreis aus Fixkosten und variablen Kosten
       (def kosten
         (fn [kartenpreis]
           \{:pre [(number? kartenpreis)]
            :post[(number? \%)] \}
           (+ 18000 (* 5 (besucherzahl kartenpreis)))))

       (deftest test-kosten
         (is (= (kosten 500) 18600))
         (is (= (kosten 400) 19350)))
   #+END_SRC

[method=direct]Hilfsfunktionen /(9)/

-  ebenso für die Funktion =einnahmen=:

   #+BEGIN_SRC clojure
       ;; berechnet die Einnahmen aus dem Produkt von 
       ;; Besucherzahlund Kartenpreis
       (def einnahmen
         (fn [kartenpreis]
           \{:pre [(number? kartenpreis)]
            :post [(number? \%)]\}
           (* (besucherzahl kartenpreis) kartenpreis)))

       (deftest test-einnahmen
         (is (= (einnahmen 500) 60000))
         (is (= (einnahmen 400) 108000)))
   #+END_SRC

[method=direct]Hilfsfunktionen /(10)/

-  zum Schluss die Funktion =profit=:

   #+BEGIN_SRC clojure
       ;; berechnet den Profit aus der Differenz zwischen
       ;; Einnahmen und Kosten bei gegebenem Kartenpreis
       (def profit
         (fn [kartenpreis]
           \{:pre [(number? kartenpreis)]
            :post[(number? \%)]\}
           (- (einnahmen kartenpreis)
              (kosten kartenpreis))))

       (deftest test-profit
         (is (= (profit 500) 41400))
         (is (= (profit 400) 88650)))
   #+END_SRC

Hilfsfunktionen /(11)/

*Regel für Hilfsfunktionen:*

*Definiere für jeden Zusammenhang zwischen Größen, die sich aus der
Problembeschreibung ergeben, eine Funktion.*

[method=direct]Hilfsfunktionen /(12)/ *So nicht!!*

#+BEGIN_SRC clojure
    (def profit
       (fn [kartenpreis]
         (-
           (*
             (+ 120
                (* (/ 15 10 )
                   (- 500 kartenpreis)))
             kartenpreis)
           (+ 18000
              (* 5
                 (+ 120
                    (* (/ 15 10 )
                    (- 500 kartenpreis))))))))
#+END_SRC

Hilfsfunktionen

-  vgl. auch Kent Beck: Best practice patterns: method invocation

-  Hilfsfunktionen entsprechen dem Prinzip der funktionalen Abstraktion

-  oder der hierarchischen Dekomposition

** Variablendefinitionen

Variablendefinitionen /(1) / Weitere Verbesserung der Lesbarkeit des
Programms durch

*Regel für Variablendefinitionen:*

** Ersetze jede Konstante, deren Bedeutung sich nicht aus dem Kontext
ergibt, durch einen sprechenden Variablennamen. *

Anmerkung: Der Begriff /Variable/ ist hier vorläufig mit /benannter
Konstante/ gleichzusetzen.

[method=direct]Variablendefinitionen /(2) / Zum Beispiel für die
Funktion =profit= und ihre Hilfsfunktionen:

#+BEGIN_SRC clojure
    (def fixkosten 18000)
        (def kosten-pro-besucher 5)
        (def basis-besucherzahl 120)
        (def besucher-preis-faktor (/ 15 10))
        (def preis-fuer-basis-besucherzahl 500)
        
#+END_SRC

(Das vollständige Programm =profit= (kino.clj) steht in Moodle zur
Verfügung.)

*Gegenbeispiel:* für die Formel zur Berechnung der Dreiecksfläche

#+BEGIN_SRC clojure
    (/ (* grundseite hoehe) 2)
        
#+END_SRC

*nicht* die Konstante 2 durch eine Variable zwei ersetzen.

** Zusammenfassung

Zusammenfassung

-  Funktionen (im Sinne der funktionalen Programmierung) stellen ein
   bedeutsames Mittel der funktionalen Abstraktion dar durch:

   -  Abstraktion konkreter Ausdrücke zu parametrisierten Funktionen,

   -  Benennung der Funktionen.

-  Abstraktion von Teilausdrücken führt durch die Einführung von
   Hilfsfunktionen zu einer Abstraktionshierarchie.

-  Eine Entwurfsvorschrift

   -  ist kein Allheilmittel,

   -  stellt eine Handlungsanleitung dar,

   -  dient der „Disziplinierung“ der Programmierer.

   -  Phase 3 stellt hohe Anforderungen:

      -  Verstehen der Problembeschreibung

      -  Vermögen, mathematische Zusammenhänge zu erkennen

      -  Einarbeitung in fremde Begriffswelt

      -  Entwicklung eigener Fachsprachen

      -  Fähigkeit zur Abstraktion



* Logische Programmierung
* Weitere ...

* bibliography:referenzen.bib

#
# Local Variables:
# lentic-init: lentic-clojure-org-init
# End:
#



